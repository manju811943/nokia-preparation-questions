
Nokia :
 
 HTML :
 ========
1. what is diff HTML and HTML5
	=> semantic tags  -> <header> <footer> <nav> <article> <section> <aside>
	=> Audio/video support
	=> local storage
	=> canvas/SVG
	=> Better SEO support  
	
2. semantic tags and why important ?
	=> Better SEO
	=> Better accessibility
	=> Easy mainitannce
	=> Screen reader friendly
	
3. DIff between 
			localstorage      		session storage    			cokies
	=> 		5-10mb					5mb							4kb
			permanently store		till tab closed				configurable
			can not send to server 	same can not 				but can be send to server
			
4. what is defer and aysnc in script loading
	<script asysnc src=a.js></script>  =>   
	<script defer src=a.js></script>   =>
	
	Feature		async			defer
	Download	Parallel		Parallel
	Execution	Immediately		After HTML parse
	Order		Not maintained	Maintained
	
	

5. diff between 
	property 	 		width/height		New line
	inline				No					No
	inline block		yes					No
	block				Yes					yes
	
6. what is DockType -> <!DOCTYPE html>
	=> it tells the browser that load the standards mode(not qruiks mode)
	
	
CSS:
============================================================================
	
1. what is box model
	=> it contains the 
		content -> padding -> border -> margin
		
2.How to set box sizing in css -> makes width including padding and border
	=> box-sizing : border-box;
	
3. Diff between display : none and visbility:hidden
	feature 			display:None 		visbility: hidden
	space Occupied 		No					Yes	
	visible 			No 					No
	
	
4. what is flex box and when to use it ?
	=> these are used for 1D layouts (	eithr row or column)
	=> we can use display : flex	
				  justify-content : center
				  aligh-item : center
				  
			
5. diff between flex and grid
	feature					felxBox						grid
	dimesion 				1D							2D
	use case 				component layouts			page layouts
	
	
6. what are the position property
	=> 	position 			Relative To
		static				Normal flow
		relative			own position
		absolute			nearest position parent
		fixed				viewport
		sticky 				scroll position
		
		
7. what is z-index ? when it works?
	It works only when position is	=> relative. absolute, fixed, sticky
	
8. what is specificity 
	=> it is prioroty order
		inline > ID > class > element
		
9. What is !important? Should we use?
	=> Forced prioroty
	but it breaks mainitanablity and avoid in production
	
10. Difference between em vs rem vs px

	Unit 			Based on
	px 				Fixed
	em 				parent font size
	rem 			root (html) font size
	=> rem is prefered for responsive
	
11. what is Responsive design:
	Media queries   => @media(max-width:786px){
						.card {width: 100%}
						}
	Flex layouts
	rem
	mobile-first approach 
	boostrap, materal library
	
12. how to optimizse css performce
	=> avoid deep selector
	=> use shortend
	=> use transfrom isntead of top/left
	=> minify css
	=> avoid 
	
13. what is Reflow : layout change eg: width, height
			RePaint: visual change eg: color, back-ground color
			

14. How center a div
	display : flex
	justify-content : center
	aligh-item : center

15. How to make sticky header
	=> position : sticky
	   top: 0;
	   
	   
16. how to create equal hight  cards 
	display : flex
	aligh-item : stretch;
	
17. how to hide scroll bar but allow scroll
	:: webkit-scrollbar {
		display : none
		}
		
18. Why CSS loads before JS?
	to avoid Flash of unstyle content
	
	

	Java script :
	================

1. what is Hoisting :
	variable and fucntion are moved to top of the scopre during compiltaion.
		
			=> Why it happens :
				=> JS execution 2 phase
					1.Creational  => 1. create execution content	
									 2. Allocate memory
									 3. fucntion and variable declaration
					2.Executional
	
	Eg: console.log(a)  //undefined
		var a = 10;
		
		console.log(b) // referenc error
		let b = 20;
		
2. what is Temporal dead zone :
	=> time between the variable declaration and initialization when access causes error
		applies to:
		let
		const
		
3. Difference between == vs ===
	==  will check for value comparision
	=== will check for value and type of data comparision
	
4. what is closure 
	=> the fucntion that are remember outer scoped varaible to local scoped even after execution
	Eg:	fucntion outer(){
			let count = 10;
			return fucntion inner(){    // used in call backs, data hiding
				count ++
				console.log(count)
			}
		}
		
5. what is Event Loop ?
	js is single thread but handle async using:
	=> call stacks
	=> web APIs
	=> call back queue
	=> event loop
	
6. what is call stack
	=> used to track the funtion execution order
		Eg: stack over flow happen when recursion doesn't stops.
		
		
7. what is diff between undefined and null
	feature				null 					undefined
	meaning				intentionally empty		Not assigned
	type 				object					undefined
	
	
8. Difference between call, apply, bind

	method 				Execute immidiatly 				Arguments
	call				yes								comma separated
	apply				yes								array
	bind				yes 							array but return fucntion
	
9. what is prototype :
	js uses prototype based inheritance
	every object has parent proto eg: __proto__ -> prototype chain


10. what is promise :
	=> use for aysnc operation
		resolve 
		reject
		
11. Difference between async/await vs promise
	async/await used to write promise way of code
	=> cleaner code
	=> easier error handling
	=> readable
	
12. what is callback hell
	=> Nested callbacks causing unreadbale code
		solved using : aysn/await
		
13. what is debounce => exceute after dealy ends -> used in search input
			throttling => execute at fixed interval of time  -> used in scroll events
			
14. shallow copy -> Object.assign()
	deep copy  -> JSON.parse(JSON.Stringfy(obj))
	
	
15. How to prevent memory leaks?
	=> remove event listener
	=> clear timers
	=> avaoid global variable
	=> avoid closures holding big data
	
16. diff between map and forEach
	feature					map 			forEach
	return value 			new array 		undefined
	chainable 				yes 			no
	
	
17. diff find and filter
	filter 							find
	return new array 				return first match
	multiple values 				single value
	

18. reduce -> used to accumulate the values
	[1,2,3,4].reduce((a,b) => a + b)
	
	
19.	const str = "hello";  reverse string
	console.log(str.split('').reverse().join(''));
	
20. remove dupliactes'
	let  val  = [1,2,4,2,4,5,5,3,7]
	let newval = [...new Set(val)]
	console.log(newval)
	
	
	
		Angular :
	==========================================================

1. main building blocks of Angular
	modules, components, templates, servcies, depedency injections, RxJs, Routings,
	
2. diff between components and modules

	Component						Modules
	UI building blocks				logical grouping
	has html/ css					organise the components
	control views 					bootstrap the views
	
3. what are decorator:
	these are used to add the metadata
		@Component, @Injecatble, @ngModule, @Input, @Output, @viewChild
		
4. what are data binding
	string interpolation
	property bidning
	event binding
	two way binding
	
5. what is change detections
	Angualar mechanism to update the view when the data changes.
	trigger happens:
		Event	
		Http call
		Timer
		input change
		
6. diff between default and onPush change detections

	Feature					Default 					onPush
	checks 					whole component tree		only input reference change  eg: changedetection: ChangedetectionStrategy.onPush
	performce 				slower						faster
	used in 				normal apps					larger scale apps


7. how manually trigger change detection
	changedetecionRef.detectChanges()
	markForCheck()
	
8. diff between Observable and promises
	
	Feature					Observable				promise
	multiple values 		yes						No
	lazy 					yes 					No
	cancelable 				yes 					No
	
9. Diff between the subject and behaviour subject
	
	Feature					subject					BehaviouralSubject
	initial value 			No 						Yes
	last value replay		No 						yes	
	
	
10. diff between the switchmap, merge map and concat map
	
	operator 					Behavious
	switch Map					cancel the previous request    -> Search API typing:
	merge Map 					parallel execution             -> Parallel execution (Bulk upload):
	concat map 					sequential exceution  			-> Order important (Payment processing):
	
11. what is unsubscribe ? why it important ?
	prevents :
		memory leaks
		performce issue
		
		=> can use takeUntil()
					async pipe
					unsubscribe()
			
12. how to improve the performce of Angualar
	=> lazy load  -> Loads modules only when route accessed.
	=> onPush
	=> tackBy  -> Improves DOM rendering.
	=> async pipe
	=> AOT complilation
	=> preloadong strategy
	
13. why DI is Angualr?
	=> loose coupling
	=> testablity
	=> Resuablity
	
14.Difference between providedIn root vs module providers
	root -> provide singleton service across the app
	
	
15. how to pass data between component
	=> @input/ @output
	=> Shared services
	=> Router state
	=> Behavious subject
	
					
16, diff between Activate Route and Router

	ActivateRoute 					Router
	Read the param 					Navigate routes
	Snapchat						Navigation control
	
17. How to protect Routes
	=> Auth guards
	=> canActivate
	=> canLoad
	
18. Diff Template driven and Reactive forms
		
		Feature					Template					Reactive
		scalability 			Low							high
		validation				html						ts file
		testing					hard						easy
		dynamic array			hard to implement			easy to implement
	
19. diff viewChild and content child
	
					ViewChild 							ContentChild
	Can ref of 		child component templates			projected content templates
	
	
20. what is ngZone ?
	=> control angualr change detection when values trigged
		used for performce tuning
	
21. what is Render2 ?
	=> used for safe DOM manipulation
	
22. what is dynamic component loading ?
	loading component at runtime.
	
23. APi is calling multiple times how to fix?
	=> share reply
	=> cache result in services
	=> avaoid multiple subscription
	
	
24. large table performce issue ?
	=> virtual scrolling
	=> pagination
	=> onPush
	=> tackBy
	
25. How to handle the global error handling ?
	=> ErrorHandler
	=> httpInterceptor
	
26. waht is Interceptor ?
	=> add token
	=> logging
	=> error handling
	
	
27. diff between Cold and Hot Observable

	Cold : creates a new execution per subscriber
			Eg: http call
	
	Hot : share same execution
			Eg: subject and Websockets
			
	=> http observable cold by deafult, using shareReplay makes it hot
	
	
28. what is shareReplay and when to use it ?
	=> caches last emmited value and share among subscribers
		Eg: this.http.get(url).pipe(
				shareReply(1);
			)
		=> improve the performce
		=> prevent multiple API calls.
		
		
29. Types of Subject:

	Type 					Behaviout
	Subject 				No intial value
	BehaviouralSubject		Has initial + last value
	ReplaySubject 			Replays n values	
	AysncSubject 			emit last value on complete
	

30. How can avoid nested subscription
	=> we can use switch map and merge map
	
31. How angualr change detection works internally ?
	=> Zone.js
	=> trigger on async event
	=> Traverse component tree
	
32. onPush => onPush reduce unneccessary checks and improve redendering performce in large application

33. Angualr app slow , how to debug ?
	=> chrome devtools
	=> check change detection
	=> check bundle size
	=> identify reredner issue
	
	
34. Large list slow rendering - solutions ?
	=> trackBy
	=> pagination
	=> aysnc
	=> virtual scroll
	=> onPush
	
35. How to reduce bundle size ?
	=> lazy load
	=> tree shake : Tree shaking removes unused imports, functions, services, and modules from the production build.

			Eg : ‚ùå Bad (may include unused service)
					@NgModule({
					  providers: [MyService]
					})
					export class AppModule {}

				‚úÖ Best practice (tree-shakeable)
					@Injectable({
					  providedIn: 'root'
					})
					export class MyService {}
					‚úî If MyService is never used ‚Üí removed automatically

		=> It works by default in production builds.  => ng build --configuration production

	=> remove unused library
	=> standalone component
	=> compression
	
36. How do you structure of Angualr app
	-> core/
	-> shared/
	-> auth/
	-> features/
	-> dashboard/

37. how to manage state in Angualr	
	=> BehaviouralSubject
	=> NgRx
	=> Signals
	

38. when to use NgRx ?
	=> multiple component sharing data
	=> complex data flow
	=> cache management
	
39. How to handle the API cache ?
	=> shareReplay
	=> BehaviouralSubject
	=> map cache
	
40. Smart vs Dumb components
	=> smart
			=> API call
			=> state handling
			
	=> dumb 
			=> only UI
			=> input/output
			
	=> Improve the resuablity

41. How do you write testable code ?
	=> avoid tight coupling
	=> use interfaces
	=> use depedency injection
	
42. Eg for BehaviouralSubject code
	const val$ = new BehaviouralSubject(10);
	
	val$.subscribe(e-> console.log(e) // 10
	
	
43. API is getting callled 3 times when component loads, why ?
	=> beacuse multiple subscription are created.
	

44. How do you avoid memory leaks?
	=> using async pipe, takeUntil pattern, unsubscribe on destroy and removing event listeners
	

45. How to design scalable Angular architecture?
	I follow 
	=> core/ share/ feature module structure/ smart-dumb component pattern 
	=> centralize service
	=> lazy load feature
	=> modules
	=> state management
	
	
46. How to Prevent XSS (Interview Answer)
	‚úî Escape user input
	‚úî Avoid innerHTML
	‚úî Use Angular built-in sanitization
	‚úî Use Content Security Policy (CSP)
	‚úî Validate input

	=> XSS (Cross-Site Scripting) is a client-side attack where malicious scripts are injected into web pages and executed in the user's browser. It can be prevented using input sanitization and Angular‚Äôs built-in template escaping.

	=> CSRF is an attack where a logged-in user's browser is tricked into sending unauthorized requests to a trusted server. It is prevented using CSRF tokens, SameSite cookies, or by using token-based authentication like JWT instead of cookies.
	
	
47. what is an Angular library ?
	=> For sharing the UI compoents, services, , directives, and utilities access multiple projects
	=> An Angular library is a reusable package that contains:
		=> Component
		=> Services
		=> Pipes
		=> Directives
		=> Utilities
		
		that can import into multiple projects
		
		
	=> Example use cases:
		Common Button Component
		Shared Auth Service
		Common Header/Footer
		Custom Validators
		
	steps :
			steps 1:
				=> ng generate library shared-ui
				
				=> projects/
					 ‚îî‚îÄ‚îÄ shared-ui/
						 ‚îî‚îÄ‚îÄ src/
							 ‚îî‚îÄ‚îÄ lib/
								 ‚îú‚îÄ‚îÄ shared-ui.module.ts
								 ‚îú‚îÄ‚îÄ shared-ui.component.ts
									
			step 2 : generate component inside the library
				=> ng g component button --project=shared-ui

			step 3: Export Component From Library Module
			
			step 4 : ng build shared-ui  => dist/shared-ui/ -> this deployable
			
			step 5 : Version Your Library  
				=> in the - projects/shared-ui/package.json -> "version" : "1.0.0"
				
			step 6 : Publish Internally (3 Enterprise Options)
			
					Option 1:  Private NPM Registry (Recommended) -> 1. Nexus
								=> publish => npm publish
								=> install in any project => npm install @company/shared-ui
						
					Option 2:  Git Based Installation (Quick Setup)
								=> npm install git+https://github.com/company/shared-ui-lib.git
								
					Option 3 : Local Tar Package (Offline Mode)
								=> npm pack -> It will create .tqz file 
								=> npm install shared-ui-1.0.0.tgz

						
															 
															
			
			Step 6: Use Library in Your Application
				
				import { SharedUiModule } from 'shared-ui';

					@NgModule({
					  imports: [
						SharedUiModule
					  ]
					})
					export class AppModule { }
					
			step 6 : Use Library Component in Any Component HTML
				=> <lib-button></lib-button>


48. Diff between Javascript and TypeScript

	| Feature         | JavaScript        | TypeScript               |
	| --------------- | ---------------   | ------------------------ |
	| Typing          | Dynamic           | Static                   |
	| Compile Step    | ‚ùå No             | ‚úÖ Yes                   |
	| Error Checking  | Runtime           | Compile time             |
	| OOP Support     | Limited           | Strong (Interface, Enum) |
	| Tool Support    | Basic             | Excellent (IntelliSense) |
	| Scalability     | Hard              | Easy                     |
	| Angular Support | ‚ùå Not supported  | ‚úÖ Required              |

				

				
	Core Java :
===========================================================================================

1. JDK vs JRE vs JVM
	
	component 		Role
	JDK 			Developement tool + JRE			
	JRE				JVM + library
	JVM 			Execute byte code
	
2. what happens when you run java programming ?
	=> .java -> compile -> .class -> class loader -> Byte code 	-> JVM -> execution
	
3. Java memory areas
	=> Heap (Objects)
	=> stack memory (methods)
	=> Metaspace (Class metadata)
	
4. Diff between Heap and stack
	
		Stack 					Heap
		thread safe 			Not thread safe
		fast 					slower
		methods class 			Objects stored
		
5. what is garbage collectors 
	=> automatic memory cleanup of unused Objects in Heap
	
6. Types of Garbasge collectors
	=> serial GC
	=> parallel GC
	=> G1 GC (Default)  => It balance throughput and low pause time.
	
	
7. what are the meory leak in Java
	=> when objects are not eligible for GC but not used.
		Eg: static collections
			listener not removed
			cache not cleared
			
8. can we overide static method 
		=> No, it is method hiding
	
9. diff between String, string buffer, string builder

	Feature				String 			String buffer 				String builder
	mutable 			No				yes							yes
	thread safe 		yes 			Yes							No
	performce			slow  			medium						faster
	
	
10. why string is immutable ?
	=> security
	=> thread safe
	=> string pool
	=> hashcode caching
	
11. what is contract between equal() and hashCode()
	=> if equal() -> true, hashcode must be same
	=> used in 
		HashMap
		HashSet
		
12, diff 
	ArrayList 							LinkedList
	fast access							slow access
	slow insert/ delete in middle		faster insertion
	less memory 						more memory
	
13. Diff 
	Hashmap					ConcurantHashMap
	Not thread safe 		thread safe
	faster					slight slower	
	Allowes null key 		No null key
	
14. why hashMap allows one null
	=> beacause hashCode not required for null
	
15. diff
	Fail-fast					fail-safe
	throws an exception 		no exception
	ArrayList					copyOnWriteArray list
	Eg: concuranthashMapException
	
	
16. DIff
		Sleep 					wait
		thread class			Object classs
		doesn't release lock	release lock
		
17. what is valatile keyword ?
	=> visibility
	=> avaoid cacheing
	
18. what is deadlock ?
	=> two thread are lock eachother's resource
		
19. what is thread pool ?
	=> Reuse thread
	=> performce
	=> Resource controll
	
	
20. Funtional Interface ?
	=> interface having one abstract method
		=> Runnable
		=> Comparator
		
21. app is slow, what you check ?
	=> GC logic
	=> thread dump
	=> BD calls
	=> memory leaks
	=> CPU usage
	
22. what is class loader heirarchy ?
	=> Bootstrap
	=> Extension
	=> Application
	
23. what is Escape Analysis ?
	=> JVM analysis the object 	allocation to imrpove the performce
		=> on stack instead of heap
		=> remove synchronisation
		
24. How to moniter the memory issue in production ?
	=> Jconsole
	=> virtual VM
	=> Heap dump
	=> thread dump -> jstack command to get running threads info in cmd line
	
25. what is young gen and old gen 
	young -> short lived object
	old -> long lived object
	
26. what is forkJoinpool
	=> used for parallel processing	
		Eg: parallel streams
		
	
27. what is Reflection API ?
	=> RunTime class inspection
	=> method invocations
	
	used In :
		=> Spring
		=> Hibernate
		
	=> disadvancatge of Reflections 
		=> performce overhead
		=> security risk
		=> memory leaks
		
28. Diff between	
	Serialization				Externalization
	Automatic					manual control
	less control				more control
	
	
29. why ConcurrentHashMap faster than Hashtable ?
 		=> No global lock
		=> bucket level locking
		
		
30, what is weak HashMap ?
	=> entries are removed when key is garbage collected 
	used for :
		cache
		
		
31. what happens internally when springBoot app start
	=> Main class run -> @SpringBootApplication
	=> Auto configuration
	=> component scanning
	=> bean creation
	=> Embded server starts
	=> Appilication ready event fired
	
	
32.What is autoconfiguration ?
	=> Springboot automatically configured beans based on 	
		=> classpath
		=> propeties
		=> conditions
		
		
33. stereo type annotations
	@Component	
	@Service
	@Repository -> tanslate db execution
	
	
34. How SpringBoot interact with JPA interanally ?
	=> Hibernate
	=> Data Source
	=> EntityManagerFactory
	=> TransctionManager
	
	Auto configuration via
		spring.datasource.*
		spring.jpa.*
		
		
35. How @Transctional works internally ?
	=> AOP will create proxy around method
	=> Intercept the method
	=> Begin transction
	=> commit/ roll back
	
	
36. why sometimes @Transctional will not work ?
	=> internal method call
	=> private method
	=> final method
	=> same class invocations
	
	
37. RunTimeException 			-> Roll back
	Checked/compile time Exception -> No roll back
	
	
38. What is second level cache ?
	=> Hibernate cache across the session
	
39. How do you version API's ?
	=> URL versioing
	=> header versioning
	=> param versioning
	
	
	
40. Integration of Microservice to open source software system :
	common open source software system
		Messaging		-> kafka, RabbidMQ
		Cache 			-> Redis, EH cache
		API gateway 	-> Nginx
		logging 		-> ELK
		
		
		so, connecting your sprinboot Microservcie to open source platfrom, to send, receive, process, moniter, or stored the data
		Eg: publish event to Kafka
			store data in Redis cache
			
		=> for Network Management system :
			your springboot app will communicate with NMS platform to fetch metrics, send alerts, push data, or automate network operations
			Eg: openNMS
			
		
41. Code Review :
	=> code quality  (unnecessary loops, multiple database queries, input validation and sensitive data handling)
	=> security aspects
	=> Maintainbility
	=> performce consideration
	=> Functionality & Business Logic
	=> code readability and clean code
	=> Exception handling
	=> Test coverage
	
	=> Reusability and Scalability
	=> Naming conventions
	=> code duplication
	 
	
42. Ethernet :
	it is communication protocal that defines how data transmitted over wired networkd using cable such LAN cable
	
	
43. Swing :
	swing is a part of java foundation class that privide componets to create platforms independent desktop based apps
	
	
44. what is live lock ?
	=> live lock is situation where threads are active and running, but no actual progress is made beacsue they keep resposnidng each other.
		=> Threads are not blocked
		=> threads are not waiting
		=> CPU is being used
		=> but no work is getting completed
		
	=> How to prevent :
		=> add random time for retrying
		=> limit retry attempt
		=> better lock strategy
		=> avoid busy waiting.  wait(), notify()
		
45. What is Parrallel streams :
	=> allow stream operation to run parallel using multiple threads to improve performce for large appln
	Eg: list.parallelStream().forEach(n-> sout(n))  => Note : order is not guaranteed.
		=> improve CPU usage								 use forEachOrdered() if order needed
		=> multiple threads
		=> faster heavy loads.
		

45. Diff between :

	DeadLock 							Live Lock
	thread are blocked					thread are running
	waiting forever						actively retrying
	No CPU usage						High CPU usage
	Resource locked						No Resource lock
	
	
46. Both Comparable and Comparator are used for object sorting in Java.
	=> Comparable Inteface:
	
		=> used to define natural ordering sort
		=> has only one method -> compareTo(Object o)
		
			Eg: class Employee implemets Comarable<Employee>{
			
				priavte Integer id;
				private Sring name;
				
				Employee(Integer id, String name){
					this.id = id;
					this.name = name;
				}
				
				public int compareTo(Employee e){
					return this.id = e.id;
				}
				}
				
	=> Comparator Interface
		=> Used to define external sorting logic
		=> create mutliple sorting logics
		=> have one method -> compare(Object o1, Object o2);
		
		Eg: public class NameComparator implemets Comparator<Employee>{
		
			public int compare(Employee e1, Employee e2){
				return e1.name.compareTo(e2.name);
			}
		}
		
		
47. FlatMap : examples
	Eg 1: 
		List<List<String>> list = Arrays.asList(
                Arrays.asList("java", "python"),
                Arrays.asList("Angular", "react"),
                Arrays.asList("js", "php")
        );

        list.stream().flatMap(l-> l.stream()).forEach(n-> System.out.println(n));
		
	Eg 2 :
	 List<List<Integer>> numbers = Arrays.asList(
                Arrays.asList(1, 2, 3),
                Arrays.asList(3, 4, 5),
                Arrays.asList(5, 6, 7)
        );

        List<Integer> num = numbers.stream().flatMap(l-> l.stream()).distinct().collect(Collectors.toList());

        System.out.println(num);
		
		
48. Java 17 feature :
	=> Sealed class
	=> Records (FINAL) -> USed to create immutable data class automatically
		Eg: public Record Employee(int id, String name);
	=> Text Blocks (FINAL) -> multip line string without \n 
		Eg: String json = """ 
				{
					"name":"Ram"
				}
			"""
		
	=> Encapsulation -> Improved performance
	=> Switch Expression
	
	
49. Java 21 features :
	=> Virtual Threads (FINAL) -> It make highily scalable concurant application
		Benefits :
			=> millions of thread
			=> less memory usage
			=> ideal of Rest API
			=> Perfect for micorservcue
			
	=> Record Patterns (FINAL) -> Destructure records objects easily
	
	=> String Templates 
		Eg: String name = "Ram";
			String msge = STR."Hello \{name}"
	=> Unnamed Classes & Instance Main
		Eg : void main(){
				sout("");
			}
			
50. Records :
	=> A Records is used to create a data carrier class that automatically provides: or creating immutable data objects.
		=> Constrotor
		=> Getters
		=> equals()
		=> hashCode()
		=> toString()
		=> immutable fields
	
51. List<String> list = Arrays.asList("apple", "avacado", "banana", "brinjal", "cat");
        System.out.println(list.stream().collect(Collectors.groupingBy(n-> n.charAt(0))));
		
		o/p : {a=[apple, avacado], b=[banana, brinjal], c=[cat]}
		
		
52. String s1 = "ABC";
    String s2 = "ACD";

    String s3 = s1.concat(s2);

        Set<String> s4 = new HashSet<>();


        System.out.println(Arrays.stream(s3.split(""))
                .collect(Collectors.groupingBy(Function.identity(),Collectors.counting()))
                .entrySet()
                .stream().filter(ele-> ele.getValue() > 1)
                .map(e-> e.getKey())
                .collect(Collectors.joining()));  // AC
				
				
53. Find indices whose sum equals target.

	Example
	[2,7,11,15], target=9
		
		int arr[] = {2,17,11,7}; // target=9
        for (int i = 0; i < arr.length; i++) {
            for (int j = i+1; j < arr.length; j++) {
                if(arr[i] + arr[j] == 9){
                    System.out.println(arr[i]  + " " + arr[j]);
                }
            }
        }
		
		
54. count the character frequency and print them in acsending of their values

		Eg:  String str = "banana";
			 Arrays.stream(str.split(""))
                .collect(Collectors.groupingBy(Function. identity(), Collectors.counting()))
                .entrySet().stream()
                .sorted(Map.Entry.comparingByValue())
                .forEach(n-> System.out.println(n));
				
				
55. print all the subtring of given string

	 String str = "ABC";

        for (int i = 0; i < str.length(); i++) {
            for (int j = i+1; j <= str.length(); j++) {
                System.out.println(str.substring(i,j));
            }
        }  
		   o/p  A
				AB
				ABC
				B
				BC
				C
	
56. You want to fetch 20 records starting from the 5th row and return only first name and last name.

	SELECT first_name, last_name
	FROM users
	LIMIT 20 OFFSET 4;
	
57. What is Lookups
	=> Lookup means quickly finding a value or record using a key or reference.
	
		eg 1: Programming Example (Java Map Lookup)
				Map<Integer, String> map = new HashMap<>();
				map.put(101, "Manju");
				map.put(102, "Rahul");

				// Lookup
				System.out.println(map.get(101));
				
		eg 2: Database Lookup Example (SQL)
			SELECT name 
			FROM employee 
			WHERE emp_id = 101;
			
			üëâ emp_id = 101 is the lookup key
			
			
58. How Springboot App works and do thing internally automatically
	
		Simulating in plain java as below :
		
		üöÄ SpringBootSimulator.java
			
			import java.util.*;

			class HelloController {

				public String hello() {
					return "Hello World from Spring Boot Simulation";
				}
			}

		public class SpringBootSimulator {

			public static void main(String[] args) {

				System.out.println("Starting Application...");

				// Step 1: Create IOC Container
				Map<String, Object> container = new HashMap<>();

				// Step 2: Create Bean
				HelloController controller = new HelloController();
				container.put("helloController", controller);

				// Step 3: URL Mapping
				Map<String, String> urlMapping = new HashMap<>();
				urlMapping.put("/hello", "helloController");

				// Step 4: Simulate Request
				String requestUrl = "/hello";

				HelloController bean =
						(HelloController) container.get(urlMapping.get(requestUrl));

				String response = bean.hello();

				System.out.println("Response: " + response);
		}
	}

	
		=> ‚≠ê Architecture Diagram Explanation (Tell Verbally)
			
				Main Class
					‚Üì
				ApplicationContext Created
					‚Üì
				Component Scan
					‚Üì
				Bean Creation
					‚Üì
				Dependency Injection
					‚Üì
				Embedded Server Startup
					‚Üì
				DispatcherServlet Mapping
					‚Üì
				Controller Execution


59. If multiple interfaces have the same default method and a class implements both, Java will NOT automatically choose one. 
	
	=> It causes compile-time error.
	
	=> Choose One Interface Explicitly
		
		class Test implements A, B {
			@Override
			public void show() {
				A.super.show();   // Calls A's method
			}
		}
		
60. Pre-Processor and Post-Processor diff
	=> Pre-Processor : 
		1. üëâ A Pre-Processor is something that executes BEFORE the main logic/action/request is processed.
			Examples:
				Authentication check
				Request validation
				Logging request data
				Adding headers
				
	==> Post-Processor : üëâ A Post-Processor runs AFTER the main logic/action/request is completed.
			Used for:
				Logging response
				Modifying response
				Cleanup tasks
				Auditing


61. ‚úÖ What is @ConfigProperty?
			
	==> @ConfigProperty is used to read configuration values from external sources like :
		application.properties
		environemnt varibale
		system properties
		

62. ‚úÖ What is CompletableFuture?
	==>  CompletableFuture is java classs used to perform asyncrnous , non blobking, opeartion ans handle result when they become avaibale
	
	=>  ‚úî Non-blocking
		‚úî Callback based
		‚úî Better performance
		
	=> ‚úÖ Important Methods (Interview Must-Know)
		1. runAsync() ‚Üí No Return Value
		2. supplyAsync() ‚Üí Returns Value
		3. thenApply() ‚Üí Transform Result
		4. thenAccept() ‚Üí Consume Result
		5. thenRun() ‚Üí No Input No Output


63. ‚úÖ What is Saga Pattern?
	==> Saga pattern is used to manage distiurbited transction across the multiple micorsevices by using  a sequential local transction	
	
		‚úÖ Flow (Choreography)
			Order Service
				‚Üì (OrderCreated Event)
			Payment Service
				‚Üì (PaymentCompleted Event)
			Inventory Service
			
		‚ùå Failure Case
			Inventory Failed
			  ‚Üì
			Payment Service ‚Üí Refund Event
			  ‚Üì
			Order Service ‚Üí Cancel Order
			
			
64. OOPS:
	==> Encapsulation ‚Äì Data Hiding & Protection
		-> Encapsulation means wrapping data (variables) and methods into a single unit (class) 
			and restricting direct access to the data
			
			Eg: Bank Account
					You cannot directly access balance
					You must use deposit() / withdraw()
					
			‚úÖ Benefits
				Improves security
				Controls how data is modified
				Easier maintenance
				
	==> Inheritance ‚Äì Code Reusability
		-> Inheritance allows a child class to acquire properties and behavior of a parent class.
			
			Eg: Bank Account
					you have Gold accont class have some intrest calculate method
					same can used in Slilver account class
			
	==> Polymorphism ‚Äì One Thing, Many Forms
		-> Same method name but different behavior depending on the object.
				
				Types :
					Compile-time (Method Overloading)
  					Run-time (Method Overriding)
					
			Eg : Payment Method
					pay() ‚Üí Card
					pay() ‚Üí UPI
					pay() ‚Üí Cash
	
	==> Abstraction ‚Äì Hide Implementation Details
		-> Showing only essential features and hiding internal logic.
			
			payment and sendSMS these will just give us methods, 
			not expose the implementation
			
65. üîπ Why static methods cannot be overridden?
			Overriding depends on runtime polymorphism, and:
			Static methods belong to the class
			They are resolved at compile time, not runtime
			So dynamic method dispatch does NOT apply to static methods.
			
		üîπ What actually happens? ‚Üí Method Hiding
			If a child class defines a static method with the same signature as a static method in the parent class, it is called method hiding, not overriding.
			
66. üîπ How ExecutorService Works in Java (Step-by-Step)
	
	==> ExecutorService is part of the java.util.concurrent package and is used to manage and execute multiple threads efficiently 
		without creating threads manually.
			
		1Ô∏è. Problem Without ExecutorService
			‚ùå Problems:
				Too many threads ‚Üí OutOfMemoryError
				No control over thread lifecycle
				Poor performance due to frequent thread creation
			
		2Ô∏è. What ExecutorService Does
				ExecutorService:
				Creates a thread pool
				Accepts tasks (Runnable / Callable)
				Assigns tasks to available threads
				Manages queueing, reuse, and shutdown
		
		
67. JOINS in SQL

	=> 1Ô∏è. INNER JOIN ‚Äì Matching Records Only
		=> Returns rows only when there is a match in both tables.
		
	=> 2Ô∏è. LEFT JOIN (LEFT OUTER JOIN)
		=> Returns all rows from left table + matching rows from right table.
	
	=> 3. RIGHT JOIN (RIGHT OUTER JOIN)
		=> Returns all rows from right table + matching rows from left table.
		
	=> 4. FULL JOIN (FULL OUTER JOIN)
		=> Returns all records from both tables
		   Non-matching rows contain NULL
		   
	=> 5. CROSS JOIN ‚Äì Cartesian Product
		=> Returns all possible combinations.
	
	=> 6. SELF JOIN in SQL (with Real-Time Examples)
	
		=> A SELF JOIN is when a table is joined with itself.
			-> when table having emp_id,  name, manager_id
			
			Eg : SELECT 
					e.name AS employee,
					m.name AS manager
				FROM Employee e
				LEFT JOIN Employee m
				ON e.manager_id = m.emp_id;

		
	üéØ Real-Time Interview Use Cases
		INNER JOIN ‚Üí Active users with orders
		LEFT JOIN ‚Üí Customers without orders
		RIGHT JOIN ‚Üí Products not sold
		SELF JOIN ‚Üí Employee-Manager hierarchy
		FULL JOIN ‚Üí Data reconciliation
		
68. How do you handle configuration changes without redeploying all services?

	=> Centralized Configuration Server (Most Common)
	
		How it works
			Store configs in Git / Vault / S3
			All services read config from a central config server
			Config changes do not require redeployment
		
	=> Dynamic Refresh (@RefreshScope)
	
		Allows beans to reload configuration at runtime.
			@RefreshScope
			@Component
			public class PaymentConfig {
				@Value("${payment.timeout}")
				private int timeout;
			}
			
	=> Environment Variables (Container-Friendly)
			Very common in Docker & Kubernetes.
	
	=> Feature Flags / Toggles (Business Config)
	
		if(featureFlagService.isEnabled("NEW_PAYMENT_FLOW")) {
			newFlow();
			} else {
				oldFlow();
		}
		
	=> Database-Stored Configuration
	
69. How do you trace a single request across multiple microservices?

	=> ‚úÖ Solution: Distributed Tracing
			Key Idea
				Generate a unique Trace ID for each request
				Pass it across all microservices
				Collect timing & metadata
				Visualize the complete request flow

70. How do you secure service-to-service communication?
	=> JWT and OAuth 2.0 (Client Credentials Flow)
	=> API Gateway as Security Gatekeeper
	=> Service Mesh (Zero-Trust Model)
		=> Service mesh automates security without code changes.
			What it provides
				Automatic mTLS
				Identity-based access
				Traffic policies
				‚úî Strongest security model
				‚úî Transparent to developers
					
				
71. How many String Objects will be created for String s1 = new String("ankit");
	=> ‚úÖ Answer: 2 String objects are created
	
		-> "ankit" ->  This literal is checked in the String Constant Pool.
					   If "ankit" is not already present, one object is created in the SCP.
				
		-> new String("ankit") -> The new keyword always creates a new object in the heap.
	
72. üîπ What is a Page Object ?

	=> A page object is java class that represent one web page (screen) of application
		
	=> It contains:
		Locators (buttons, inputs, links)
		Page-level actions (click, type, submit)
		Business methods related to that page
	
	=> üéØ Purpose of Page Objects
			1Ô∏è. Separation of Concerns
				Test classes ‚Üí test flow & validation
				Page classes ‚Üí UI elements & actions
				
73. Your Spring Boot app works locally but fails after deployment. What do you check first?

	=> Application Logs (Most Important)
	=> Environment & Configuration Mismatch
	=> Port & Server Configuration
	=> Database Connectivity
	=> Packaging & Build Issues
	=> External Dependencies
	=> Java & Runtime Version Mismatch
	=> Security & CORS Issues (If UI works locally)
	=> Enable actuator health
	

74. | Feature     | HashMap    	| LinkedHashMap        | TreeMap        |
	| ----------- | ----------  | -----------------    | -------------- |
	| Ordering    | ‚ùå No       | ‚úÖ Insertion order   | ‚úÖ Sorted order |
	| Internal DS | Hash Table  | Hash Table + DLL     | Red-Black Tree |
	| Performance | ‚≠ê Fastest  | ‚≠ê‚≠ê Medium         | ‚≠ê Slowest      |
	| Null Key    | ‚úÖ One      | ‚úÖ One              | ‚ùå Not allowed  |
	| Null Values | ‚úÖ Allowed  | ‚úÖ Allowed          | ‚úÖ Allowed      |
	| Thread-safe | ‚ùå No       | ‚ùå No               | ‚ùå No           |
	
	=> HashMap fails when order or thread safety is required, 
	=> LinkedHashMap fails in memory-critical systems, 
	=> TreeMap fails with null keys, bad comparators, or when high performance is needed.
	
	
	
75. Behaviour of  HashMap in Multi-threaded env.
	=> üëâ HashMap is NOT thread-safe.
			Using it concurrently without synchronization can lead to data corruption, 
			lost updates, exceptions, and (in older Java) infinite loops.
			
	üî¥ What goes wrong with HashMap in multi-threading?
		1. Data Inconsistency (Lost Updates)
		2. Internal Structure Corruption (Very Dangerous)
		3. ConcurrentModificationException (Fail-Fast)
		4. Visibility Issues
		5. NullPointerException (Rare but Real) => During concurrent resize, a thread may read a partially updated bucket.
		

76. üîπ What is Method Hiding in Java?

	=> Method hiding happens when a subclass declares a static method with the same name and parameters 
		as a static method in the parent class.
		
		class Parent {
			static void show() {
				System.out.println("Parent show()");
			}
		}

		class Child extends Parent {
			static void show() {
				System.out.println("Child show()");
			}
		}
	
	
77. What is @Lazy?

	=> üîç What @Lazy Changes 
			Bean is NOT created at startup
			Bean is created only when first requested
			Improves startup performance


78. why lambda inroduced ?

	=> Lambdas were introduced to reduce boilerplate code, enable functional programming, 
		support the Streams API, and make Java code more readable, expressive, and 
		scalable‚Äîespecially for collections and concurrency.
		
	Advanctages :
	1. Enable Functional Programming in Java
	2. Better Support for Streams API
	3. Cleaner Concurrency Code
	4. Encourage Declarative Programming  : employees.stream()
											 .filter(e -> e.getAge() > 30)
											 .toList();
	5. Reuse via Functional Interfaces
	6. Improve Readability & Maintainability.
	
	
79. Peek() method in streams
	=> the peek() in java stream method is mainly used for debugging, logging or monitering elements 
	   while a stream pipeline is executing, without modifying the streams
	
	Eg : Stream<T> peek(Consumer<? super T> action)
	
			1. It performs the given action on each element
			2. Returns the same stream
			3. It is an intermediate operation
			4. Executes only when a terminal operation is called
			
		Eg:	employees.stream()
			.peek(e -> System.out.println("Original: " + e))
			.filter(e -> e.getSalary() > 50000)
			.peek(e -> System.out.println("After filter: " + e))
			.map(Employee::getName)
			.peek(name -> System.out.println("Mapped name: " + name))
			.toList();
			
80. Can Optional be null?
	=> An Optional reference can be null, but it should never be null in practice. 
		If it is, the design is wrong and defeats the purpose of using Optional
		

81. How to Make a Class Serializable ? just make implements your class to Serializable (Marker interface)
	=> import java.io.Serializable;

		class Employee implements Serializable {
			int id;
			String name;
			double salary;
		}
		
	Eg : üîπ Serialize (Object ‚Üí File)
	
			ObjectOutputStream oos =
				new ObjectOutputStream(new FileOutputStream("emp.ser"));
			oos.writeObject(emp);
			oos.close();
			
		üîπ Deserialize (File ‚Üí Object)
		
		ObjectInputStream ois =
			new ObjectInputStream(new FileInputStream("emp.ser"));
		Employee emp = (Employee) ois.readObject();
		ois.close();
		
		üëâ JVM checks this marker to decide behavior.
		
82. Why default methods were introduced ? how multiple default method conflicts are resolved ?

	=>  Default methods were introduced to evolve interfaces without breaking existing code and 
		to support Java 8 features like Streams and Lambdas. Conflicts are resolved by overriding 
		the method or explicitly calling the desired interface‚Äôs default implementation.
		
	=> default method not required to override in implemented class 
	=> static method can not be overridden
	=> abstract methods in interface are have to implenent in class but not required abstract class
	
	
83. What is Method Hiding in Java?

	=> Method hiding happens when a child class defines a static method with the same 
	   signature as a static method in the parent class.
	   
84. HashMap and ConcurrentHashMap regarding null keys and null values:
	
	=> 1Ô∏è. HashMap
		‚úÖ Allows one null key
		‚úÖ Allows multiple null values
		‚ùå Not thread-safe
		
		Eg : HashMap<String, String> map = new HashMap<>();
		
			 map.put(null, "Hello");     // ‚úÖ allowed (only one null key)
			 map.put("A", null);         // ‚úÖ allowed
			 map.put("B", null);         // ‚úÖ allowed
			 
		=> Why only one null key?
			Because keys must be unique. Since null == null, only one null key is possible.
			
	=> 2Ô∏è. ConcurrentHashMap
		‚ùå Does NOT allow null key
		‚ùå Does NOT allow null value
		‚úÖ Thread-safe
			 
		=> ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
		
			map.put(null, "Hello");   // ‚ùå Throws NullPointerException
			map.put("A", null);       // ‚ùå Throws NullPointerException
			
	=> HashMap allows one null key and multiple null values, whereas ConcurrentHashMap does not allow any 
		null key or null value because it avoids ambiguity during concurrent access.
		

85. Key difference between get() and load()

	| Method   | Who Calls It?    | Purpose                  |
	| -------- | ---------------- | ------------------------ |
	| `get()`  | You              | Retrieve value           |
	| `load()` | Cache internally | Create value when absent |
	
	
86. Hibernate Cache Types ?

	‚úÖ First-Level Cache (L1) :
		-> Enabled by default
		-> Session-level
		-> Cannot be disabled
		-> 	Not configurable
			üëâ No tuning required.
			
	‚úÖ Second-Level Cache (L2)
		-> SessionFactory-level
		-> Shared across sessions
		-> Optional
		-> Requires provider (Ehcache, Caffeine, Infinispan, Hazelcast, etc.)
		    üëâ This is what we usually tune.

	=> What Should You Cache?

		-> Not everything should be cached. Cache only:

		‚úÖ Good Candidates (Ideal for Cache)

		‚úî Read-mostly data
		‚úî Rarely updated data
		‚úî Small lookup/reference tables
		‚úî Data used frequently
		‚úî Data shared across users
		
		
87. mvn clean install 

	=> 1Ô∏è. clean
		-> Deletes the target/ directory.
		-> Removes previously compiled classes, JARs, and build artifacts.
		-> Ensures the build starts fresh.

	=> 2Ô∏è.install
		-> Runs the full default build lifecycle up to install, which includes:
		-> validate ‚Äì checks the project structure
		-> compile ‚Äì compiles source code
		-> test ‚Äì runs unit tests
		-> package ‚Äì creates the JAR/WAR file
		
88. How to Improve Code Coverage (Correct Way)

	=> Check the coverage report -> you'll know which whcih line/branch/method covered, which are missing try to coverage
	=> Write tests for uncovered code 
	=> Cover edge cases -> null checks, exception handle, catch block, else condition
	=> Mock external dependencies -> db, API call, External services
	=> Remove dead code
	
89. How do you verify a method is called twice in Mockito?
	‚úî times()
			@Test
			void shouldCallMethodTwice() {
				MyService service = new MyService(dependency);

				service.process();
				service.process();

				verify(dependency, times(2)).save();
			}
			
	‚úî At least twice : verify(mockObject, atLeast(2)).someMethod();
	‚úî At most twice : verify(mockObject, atMost(2)).someMethod();
	‚úî Never called : verify(mockObject, never()).someMethod();

	
90. How do you verify a method is called twice in Mockito? 

	=> We use PowerMock when normal Mockito cannot mock certain things.
	
		1. Static Methods
			Eg: public class Utils {
				public static String getValue() {
					return "real";
				}
			}
			
			PowerMockito.mockStatic(Utils.class);
			when(Utils.getValue()).thenReturn("mocked");

		2. Private Methods
		3. Final Classes / Final Methods (Older Mockito versions)
		
		Note : with latest version of Mockito can mock most of mocking in the abive cases
		
91. How to Make Sure GC Works Properly

	=> Remove Unused References
	=> Avoid Memory Leaks
		Common causes:
			Static collections holding objects
			Listeners not removed
			Unclosed resources
			ThreadLocal misuse
			Caches without size limit
	=> Close Resources Properly

92. What Are Atomic Variables in Java?

	=> They allow thread-safe operations without using synchronized blocks or locks.
	Eg : AtomicInteger count = new AtomicInteger(0);
		This operation is:
			‚úî Thread-safe
			‚úî Lock-free
			‚úî Faster than synchronized

93. Different OOME messages point to different root causes.

| Error Message                        | Meaning                    |
| ------------------------------------ | -------------------------- |
| `Java heap space`                    | Heap memory exhausted      |
| `GC overhead limit exceeded`         | Too much time spent in GC  |
| `Metaspace`                          | Class metadata memory full |
| `Unable to create new native thread` | OS thread limit reached    |
| `Direct buffer memory`               | NIO direct memory leak     |

	üîü Quick Checklist
	
	‚úî Identify OOME type
	‚úî Capture heap dump = enable heap dump and GC logging
	‚úî Analyze dominator tree
	‚úî Fix memory leak = fix code issues like unbounded collections or unclosed resources
	‚úî Tune JVM (last step)
	‚úî Add monitoring = to prevent recurrence.

94.How do you avoid performance issues caused by synchronization?

1Ô∏è‚É£ Understand Why Synchronization Hurts Performance
Synchronization can cause:
	Thread contention (threads waiting on locks)
	Context switching overhead
	Reduced parallelism
	Risk of deadlocks
	=> Goal: Minimize locking, not eliminate thread safety

2Ô∏è‚É£ Reduce Lock Scope (Most Important)
‚ùå Bad (large synchronized block):
		public synchronized void process() {
	    validate();
	    calculate();
	    save();
		}	
‚úÖ Good (lock only critical section):
		public void process() {
	    validate();
	    synchronized (this) {
	        calculate();
	    }
	    save();
		}
‚úî Less time holding lock
‚úî Higher throughput

3Ô∏è‚É£ Prefer Concurrent Collections
Map<String, Integer> map = new ConcurrentHashMap<>();
Why it‚Äôs faster
	Lock striping
	Non-blocking reads
	Fine-grained locking

4Ô∏è‚É£ Use Atomic Classes Instead of synchronized
‚ùå Bad
	synchronized(this) {
	    count++;
	}

‚úÖ Good(lock free, Highly scalable)
AtomicInteger count = new AtomicInteger();
count.incrementAndGet();

5Ô∏è‚É£ Use Executor Framework Instead of Manual Synchronization
‚úÖ Good
	ExecutorService executor = Executors.newFixedThreadPool(10);
	executor.submit(() -> process());

		‚úî Thread reuse
		‚úî Less contention
		‚úî Controlled concurrency
6Ô∏è‚É£ Avoid Nested Locks (Deadlock Prevention)
‚ùå Bad
	synchronized(lock1) {
	    synchronized(lock2) {
	    }
	}

‚úÖ Lock ordering or single lock strategy
‚úî Avoid deadlocks
‚úî Predictable performance

95. What are different ways to ensure thread safety in Java?
	=> Ensuring thread safety in Java means making sure that shared data remains consistent and correct when accessed by multiple threads concurrently

 1Ô∏è‚É£ Synchronization (synchronized keyword)
	=> Method-level synchronization
	=> Block-level synchronization (preferred)

 2Ô∏è‚É£ Atomic Variables (Lock-Free)
	AtomicInteger count = new AtomicInteger();
	count.incrementAndGet();

		‚úî Uses CAS (Compare-And-Swap)
		‚úî Very fast for simple operations
		‚ùå Not suitable for complex logic

 3Ô∏è‚É£ Volatile Keyword (Visibility Guarantee)
	private volatile boolean running = true

		‚úî Guarantees visibility across threads
		‚ùå Does not ensure atomicity
		
		Use when
		Single variable
		No compound operations

 4Ô∏è‚É£ Immutable Objects (Best Practice)
		public final class User {
	    private final String name;
	    private final int age;
	
	    public User(String name, int age) {
	        this.name = name;
	        this.age = age;
	    }
		}
‚úî No synchronization needed
‚úî Naturally thread-safe

 5Ô∏è‚É£ Thread-Safe Collections 
	Map<String, String> map = new ConcurrentHashMap<>();

 6Ô∏è‚É£ Executor Framework (Controlled Concurrency)
	ExecutorService executor = Executors.newFixedThreadPool(5);
	executor.submit(() -> process());

	‚úî Thread reuse
	‚úî Reduces synchronization errors

96. What is ThreadLocal and where is it used?
	=> ThreadLocal is a Java utility class that allows you to create thread-confined variables‚Äîeach thread accessing the variable gets its own independent copy, 		even though the variable is declared as a single static or instance field
	=> üëâ In simple words:
		Same variable name, different value per thread.	

	üìå Why do we need ThreadLocal?
			=> Without ThreadLocal, you would need:
					synchronized
					locks
					complex concurrency handling
			=> ThreadLocal solves:
					Race conditions
					Shared mutable state problems
					Performance issues from synchronization

97. Why does Hashtable not allow null keys or values?

=> Hashtable does not allow null keys or values to avoid ambiguity during retrieval and to maintain thread safety in a legacy synchronized design.
	Allowing null would make it impossible to distinguish between:
		-> a missing key, and
		-> a key explicitly mapped to null.

	| Feature      | Hashtable             | HashMap              |
	| ------------ | --------------------  | -------------------- |
	| Null key     | ‚ùå Not allowed        | ‚úî One allowed       |
	| Null values  | ‚ùå Not allowed        | ‚úî Multiple allowed  |
	| Thread-safe  | ‚úî Yes (synchronized)  | ‚ùå No               |
	| Legacy class | ‚úî Yes                 | ‚ùå No               |

=> Example:
		Hashtable<String, String> table = new Hashtable<>();
		table.put("A", null); // NullPointerException
		
		HashMap<String, String> map = new HashMap<>();
		map.put("A", null); // Works

=> Modern Replacement Recommendation

		‚ùå Avoid using Hashtable today
		‚úÖ Use:
			ConcurrentHashMap ‚Üí thread-safe + high performance
			Collections.synchronizedMap(new HashMap<>()) ‚Üí legacy-compatible
			Map<String, String> map = new ConcurrentHashMap<>();

	Note: ConcurrentHashMap also does not allow nulls ‚Äî for similar ambiguity reasons.

98. diff between the construcotr and Setter injection :
=> Eg: Constructor Injection 
		@Component
		public class OrderService {
		
		private final PaymentService paymentService;
		
		public OrderService(PaymentService paymentService) {
			this.paymentService = paymentService;
		}
		}


	| Aspect                | Constructor Injection   | Setter Injection      |
	| --------------------- | ----------------------- | --------------------- |
	| Injection Time        | At object creation      | After object creation |
	| Dependency            | Mandatory               | Optional              |
	| Immutability          | ‚úî Supported             | ‚ùå Not supported       |
	| Null Safety           | ‚úî Guaranteed            | ‚ùå Risk                |
	| Testing               | Easy (constructor args) | Slightly harder       |
	| Circular Dependency   | ‚ùå Not allowed           | ‚úî Possible            |
	| Recommended by Spring | ‚úî Yes                   | ‚ùå Less preferred      |

99. How do you find the longest substring without repeating characters in Java?
	=> 
		String s = "ababcbb";

		        Map<Character, Integer> map = new HashMap<>();
		        int left = 0, max = 0;
		        for (int i = 0; i < s.length(); i++) {
		            char c = s.charAt(i);
		            if (map.containsKey(c)) {
		                left = Math.max(left, map.get(c) + 1);
		            }
		
		            map.put(c, i);
		            max = Math.max(max, i - left + 1);
		        }
		        System.out.println(max); //3
		        }

100. Your application throws OutOfMemoryError due to Strings. Why does this happen?
	üîç Why do Strings cause OutOfMemoryError?

	1Ô∏è‚É£ Too Many String Objects Created (Most Common)
		while (true) {
	    	String s = new String("hello");
		}

	2Ô∏è‚É£ Excessive String Concatenation (+ in loops)
		String result = "";
		for (int i = 0; i < 1_000_000; i++) {
		    result += i;
		}

	3Ô∏è‚É£ String Pool Misuse (intern() abuse)
		for (int i = 0; i < 1_000_000; i++) {
	   		 String s = new String("user" + i).intern();
		}

	4Ô∏è‚É£ Reading Large Files / Responses into a String
		String data = new String(Files.readAllBytes(path));

	üõ† How to Fix String-Related OOME
		‚úî Use StringBuilder / StringBuffer
		‚úî Avoid intern() unless necessary
		‚úî Add eviction (LRU) to caches
		‚úî Stream large data instead of loading fully
		‚úî Remove unused references
		‚úî Tune heap size after fixing leaks

	üéØ Interview-Ready Answer (Perfect)
		An OutOfMemoryError due to Strings happens when too many String objects are created or retained, often due to excessive concatenation, misuse of String 		intern, storing Strings in long-lived collections, or loading large data into memory. Since Strings are immutable, each modification creates a new 				object, leading to high memory usage and heap exhaustion.

101 : How would you optimize heavy string concatenation inside loops?

	=> Bad : Every time we concat It will create new object in heap
			String result = "";
			for (int i = 0; i < 1_000_000; i++) {
			    result += i;
			}

	=> Best Solution: Use  StringBuffer (Single Thread : thread safe) / StringBuilder (Multi-threaded:not thread safe) 
		
		StringBuffer sb = new StringBuffer(); or StringBuilder sb = new StringBuilder(1_000_000);
		for (int i = 0; i < 1_000_000; i++) {
		    sb.append(i);
		}

102. Sorting millions of objects ‚Äî Comparable or Comparator? Why?

	| Aspect                  | Comparable            | Comparator         |
	| ----------------------- | -------------------   | ------------------ |
	| Where logic lives       | Inside entity         | Outside entity     |
	| Method                  | `compareTo()`         | `compare()`        |
	| Flexibility             | ‚ùå One natural order  | ‚úî Multiple orders  |
	| Performance             | ‚ö†Ô∏è Tightly coupled    | ‚úî More optimizable |
	| Best for large datasets | ‚ùå                    | ‚úî                  |

103. How do you avoid ConcurrentModificationException?

	To avoid ConcurrentModificationException, I modify collections using the iterator‚Äôs remove() method, use removeIf() in Java 8+, or use concurrent collections 	like CopyOnWriteArrayList or ConcurrentHashMap in multi-threaded environments. The key is not to structurally modify a collection directly while iterating 		over it.

104. When would you choose TreeMap over HashMap in real systems ?

	üëâ Choose TreeMap when you need sorted, ordered, or range-based access to keys.
		Use HashMap when you only need fast lookups with no ordering guarantees.

105. | Map Type                | Thread-Safe?     |
	 | ----------------------- | --------------   |
	 | `HashMap`               | ‚ùå No           |
	 | `TreeMap`               | ‚ùå No           |
	 | `Hashtable`             | ‚úî Yes (legacy)  |
	 | `ConcurrentHashMap`     | ‚úî Yes           |
	 | `ConcurrentSkipListMap` | ‚úî Yes (sorted)  |

106. Session management in Spring Boot

	=> In Spring Boot, session management is used to maintain user state across requests using HttpSession. By default, sessions are stored in server memory and 		tracked via cookies. For scalable systems, Spring Session is used with external stores like Redis. Spring Security also uses sessions to store 					authentication data, while modern microservices often use stateless JWT-based session management.

107. diff between primary and composite key? and how to define ?

	1Ô∏è‚É£ Primary Key
		üîπ What it is
			A Primary Key (PK) is a column (or set of columns) that:
			Uniquely identifies each row in a table
			Cannot be NULL
			Is usually single-column

			Eg:	CREATE TABLE employee (
				  emp_id INT PRIMARY KEY,
				  name VARCHAR(100),
				  email VARCHAR(100)
				);

	2Ô∏è‚É£ Composite Key
		üîπ What it is
			A Composite Key is a primary key made up of more than one column.
				üëâ Used when no single column is unique, but combination is unique.
				üîπ Example
					(order_id, product_id)
					(student_id, course_id)

				Eg : CREATE TABLE order_item (
					  order_id INT,
					  product_id INT,
					  quantity INT,
					  PRIMARY KEY (order_id, product_id)
					);

	=>  Key Differences (Interview Table)
			| Aspect         | Primary Key | Composite Key              |
			| -------------- | ----------- | -------------------------- |
			| Columns        | Single      | Multiple                   |
			| Uniqueness     | One column  | Combination                |
			| Null allowed   | ‚ùå No        | ‚ùå No                    |
			| JPA annotation | `@Id`       | `@EmbeddedId` / `@IdClass` |
			| Complexity     | Simple      | More complex               |

108. Handling failures & retries without duplication (Idempotency)
	‚úÖ 1. Idempotency Key (Most Common ‚Äì REST APIs) -> need to pass idempotent key in header
		Server logic
			Check if key exists
				If exists ‚Üí return stored response
				If not ‚Üí process request & store result
			Storage options
				Database
				Redis (preferred)
				Cache with TTL
	
	‚úÖ 2. Database Constraints (Natural Idempotency)
			Use unique constraints to prevent duplicates.
			UNIQUE (order_id, request_id)

	‚úÖ	3. Use put instead of Post wherever we can 

	‚úÖ 4. Message-Based Idempotency (Kafka / MQ)
			In async systems:
				Message may be delivered more than once
				Consumer must deduplicate
					Strategy
						Store processed messageId
						Ignore duplicates

	=> Best Practices (Interview Gold)
		‚úî Always use Idempotency-Key for POST APIs
		‚úî Store result, not just the key
		‚úî Use TTL to avoid infinite growth
		‚úî Combine DB constraints + idempotency keys
		‚úî Make consumers idempotent in async systems

üß† Interview-Ready Answer (Perfect)
		To handle failures and retries without duplication, we use idempotency. The client sends a unique idempotency key with each request, and the server 			stores and reuses the result for repeated requests instead of reprocessing. This prevents duplicate side effects during retries and is essential in 			payment, order, and distributed systems.

109. Database connection pool suddenly gets exhausted. How do you identify and fix it?
	=> When a database connection pool gets exhausted, 
		1. I first confirm it using pool metrics
		2. Then I check for unclosed connections
		3. long-running queries
		4. oversized transaction scopes
		5. I align thread pools with connection pool size
		6. enable leak detection, and analyze slow queries or thread dumps.

110. Lazy loading works locally but fails in production. What‚Äôs missing?
	üî¥ Open Session In View (OSIV) difference
			Local environment ‚Üí OSIV enabled
			Production ‚Üí OSIV disabled
			OSIV keeps the Hibernate session open until the view (response) is rendered.
	
	=> Local (default behavior)
		 spring.jpa.open-in-view=true

	=> Production (best practice)  : generally in production it should disabled, and properly handle the lazy data
		spring.jpa.open-in-view=false
			‚úî Better performance
			‚úî Cleaner architecture
			‚ùå Lazy loading must be handled correctly

	=> Lazy loading requires an active session, which usually means:
			@Transactional method
			Or eager fetching
			Or DTO mapping inside transaction

111. Thread-safe cache ‚Äì what will you use?
	=>  Use ConcurrentHashMap for simple in-memory caching, 
	=>  Caffeine for production-grade, high-performance caching.
	=>  Redis : Distributed Thread-Safe Cache

112. When would you use Thread vs Runnable vs Callable in real code?
	1. Thread : Rarely Used in Real Code
		‚ùå Why it‚Äôs discouraged
			Tight coupling (task = thread)
			No return value
			No checked exception handling
			Poor scalability
			Hard to manage lifecycle

	2. Runnable ‚Äì Most Common (Fire-and-Forget) -> Logging, background cleanup, sending emails
	3. Callable ‚Äì When You Need a Result (Most Powerful) -> DB calls, External api calls.

	| Option     | Return Value | Checked Exception 	| Best Use                  |
	| ---------- | ------------ | ----------------- 	| ------------------------- |
	| `Thread`   | ‚ùå No         | ‚ùå No              | Very rare / demos         |
	| `Runnable` | ‚ùå No         | ‚ùå No              | Fire-and-forget tasks     |
	| `Callable` | ‚úî Yes        | ‚úî Yes             	| Tasks that return results |


113. How do you debug a production issue?

üëâ 1st thing I will undertsand the issue from which layer ? 
		App?
		DB?
		Network?
		External dependency?

1Ô∏è‚É£ First: Stabilize the System (Before Debugging)
	Goal: Stop the blast radius.
		‚úî Check severity (P0 / P1 / P2)
		‚úî Reduce traffic if needed (rate limiting / feature flag off)
		‚úî Roll back if a safe version exists
		‚úî Communicate status (incident channel)
	Rule: Stability first, investigation second

2Ô∏è‚É£ Understand the Symptoms (Not the Assumptions)
	Ask:
		What is failing? (API, UI, batch job)
	Since when?
		Is it intermittent or constant?
		Which users / regions / tenants?
		Any recent deployments or config changes?
	üìå Never assume the root cause early

3Ô∏è‚É£ Check Observability Signals (Most Important)
	üîç Logs
			Error stack traces
			Correlation / request IDs
			Time patterns
	üìä Metrics
			CPU, memory, GC
			DB connections
			Thread pool usage
			Latency, error rate
=> Preferred order
	Configuration change
	Feature flag off
	Rollback
	Hotfix (only if unavoidable)
	‚ùå Avoid risky refactors during incidents

=> Post-Incident Actions (Interview Gold)
	‚úî Root Cause Analysis (RCA)
	‚úî Add missing logs/metrics
	‚úî Add alerts
	‚úî Write regression tests
	‚úî Improve runbooks

114. How do you improve performance of existing code?
	1Ô∏è‚É£ Measure First (Never Guess)
		Rule: If you can‚Äôt measure it, you can‚Äôt improve it.
	=> What to check
			Response time (p95 / p99)
			Throughput (RPS)
			CPU, memory, GC
			DB latency
			Thread pool usage

	2Ô∏è‚É£ Find the Real Bottleneck (80/20 Rule)
			Most performance issues come from:
				DB queries
				I/O (network, file)
				Blocking calls
				Excessive object creation
		üëâ Optimize the top 20% code paths that consume 80% time.

	3Ô∏è‚É£ Database Optimizations (Biggest Wins)
			Common fixes
				‚úî Add missing indexes
				‚úî Fix N+1 queries
				‚úî Avoid SELECT *
				‚úî Use pagination
				‚úî Reduce round trips

	4Ô∏è‚É£ Reduce Unnecessary Work
			Code-level improvements
				Remove redundant loops
				Avoid repeated calculations
				Cache expensive results
				Replace nested loops with maps/sets
				Avoid heavy logging in hot paths

115. => Spring Framework 7.0.2 ‚Äî released in December 2025.
	 => Spring Boot 4.0.2 ‚Äî released January 22, 2026.
	 üìå Notes on Versions
		The 3.5.x series (e.g., 3.5.10 from January 2026) is also available and widely used, but 4.0.2 is the most recent overall.
		
116. Spring Framework vs Spring Boot:

üîπ Spring Framework = This is the core framework:
		=> Dependency Injection (IoC)
		=> Spring MVC
		=> WebFlux
		=> Data access
		=> Transaction management
		=> Core infrastructure
	It is the foundation. 
	

üîπ Spring Boot :  This is a convention-over-configuration layer built on top of Spring Framework.
		It provides:
			=> Auto-configuration
			=> Embedded servers (Tomcat, Jetty, etc.)
			=> Starter dependencies
			=> Production-ready features (Actuator)
			=> Simplified setup
			=> Spring Boot uses a specific version of Spring Framework internally.
			
üîπ Think of It Like This
		=> Spring Framework = Engine
		=> Spring Boot = Car built around that engine
		
		=> The engine can be upgraded even if the car model hasn't been refreshed yet.
		
117. Why is Java 17 the minimum for Spring Boot 3.x?

	=> Because Spring Boot 3.x aligns with modern Java and Jakarta EE, and Java 17 is the first 
	   strong Long-Term Support (LTS) release that fully supports those changes.
	   
	=> Spring Boot 3.x
		=> is built on Spring Framework 6.x
		=> Spring Framework 6 requires Java 17+.
        => So spring Boot 3 automatically inherits that requirement.  
		
	=> Java 17 is the First ‚ÄúModern Baseline‚Äù LTS
	
	=> Java 17 Enables Framework Improvements
			Java 17 gives Spring:
				‚úÖ Records (for DTOs)
					=> Cleaner immutable models.
				‚úÖ Sealed Classes
					=> Better domain modeling.
				‚úÖ Pattern Matching
					=> Cleaner internal framework code.
				‚úÖ Stronger Encapsulation (JPMS improvements)
				‚úÖ Performance improvements (JVM + GC)
				‚úÖ Better Native Image support (GraalVM)
				
				Spring Boot 3 also improved:
					AOT (Ahead-of-Time compilation)
					Native image support
					
118. what is specific challenges you faced with jakartha namespace migration(javax to jakarta ?)
	=> this is exactly where most real-world pain happened during Spring Boot 2 ‚Üí 3 upgrades.(The migration from javax.* to jakarta)
	
	=> Jakarta used for : It provided standard APIs for:
			=> Servlets (web)
			=> JPA (database ORM)
			=> Bean Validation
			=> JMS (messaging)
			=> Transactions
			=> Dependency Injection
			
			some of example for where all we used jakarta
			1. jakarta.transaction.Transactional
			2. jakarta.validation.constraints.NotNull  -> @NotNull, constraints (DTO class)
			3. jakarta.persistence.Entity
			   jakarta.persistence.Id
			4. jakarta.servlet.HttpServlet
	
	1. Dependency Compatibility Hell (Biggest Problem)
		eg : Some libraries were still compiled against javax.*.
			 => javax.persistence.Entity = ClassNotFoundException: javax.persistence.Entity
			 => if your app uses Spring Boot 3 (jakarta) will not find javax
				
				Real Pain:
					=> Older versions of Hibernate
					=> Old Spring Cloud releases
					=> Custom internal shared libraries
					=> Old Swagger/OpenAPI libraries
					üëâ You had to upgrade everything.
					
						
		
119. Explain the internal working of the Stream API pipeline. How does Lazy Evaluation work?

	=> 1Ô∏è. What Is a Stream Pipeline?
		List<String> names = List.of("John", "Jane", "Adam", "Eve");

		names.stream()
			 .filter(n -> n.startsWith("J"))
			 .map(String::toUpperCase)
			 .forEach(System.out::println);
			 
	=> Pipeline has 3 parts:
			1. Source ‚Üí names.stream()
			2. Intermediate operations ‚Üí filter(), map()
			3. Terminal operation ‚Üí forEach()
			=> Nothing runs until the terminal operation executes.
	
	=> Think of it like building a chain:
			=> Source ‚Üí FilterStage ‚Üí MapStage ‚Üí TerminalStage
			
			=> No data flows yet.
				=> This is why it is called lazy.
				
120. findFirst() returns Optional<T> because a stream may be empty, and Java avoids returning null. 
		For primitive streams, it returns specialized Optional types like OptionalInt.
		
121. Genearate 6 digit OTP
	
		=> SecureRandom random  = new SecureRandom();
		int otp = 100000 + random.nextInt(900000);
		System.out.println(otp)
		
121. Coding Challenge: How would you write a Stream to count employees and sort them by salary (descending) and then name (alphabetically)?

	=>  long count = list.stream().count();
        System.out.println(count);
        List<Employee> sorted = list.stream().sorted(Comparator.comparing(Employee::getSalary).reversed().thenComparing(Employee::getName)).toList();
		sorted.forEach(n-> System.out.println(n.getName()));
		
122. which design pattern have actually implemeneted in context of microservices ?

		1. API Gateway Pattern
			üí° Purpose :
				Provides a single entry point for all clients
				Handles routing, authentication, load balancing, and protocol translation

	üîπ Implementation :
			=> Use Spring Cloud Gateway or Netflix Zuul

				Example:
				Client ‚Üí API Gateway ‚Üí Service A
									 ‚Üí Service B

				Features: rate limiting, request aggregation, authentication, logging
				
		2. Circuit Breaker Pattern :
			üí° Purpose
				Prevents cascading failures
				Fails fast when a downstream service is unavailable

		üîπ Implementation
			=> Use Resilience4j or Spring Cloud Circuit Breaker
				Example:

					@CircuitBreaker(name = "employeeService", fallbackMethod = "fallbackEmployees")
					public List<Employee> getEmployees() {
						return restTemplate.getForObject("http://employee-service/employees", List.class);
					}

					public List<Employee> fallbackEmployees(Throwable t) {
						return List.of(); // return empty list as fallback
					}
					
		3. Service Discovery Pattern :
				üí° Purpose
					Services register themselves dynamically
					Clients discover services without hardcoding URLs

		üîπ Implementation
			=> Use Eureka, Consul, or Zookeeper
				Example:
					Employee Service registers with Eureka
					Payroll Service queries Eureka to find Employee Service
	
		4. Saga Pattern / Distributed Transaction
				üí° Purpose
					Ensure data consistency across multiple microservices
					Avoid distributed 2PC (slow & brittle)

		üîπ Implementation :
				Orchestration-based Sagas: Spring Boot + Camunda/Zeebe
				Choreography-based Sagas: Kafka / Event-driven approach
				
123. üîÑ Sync vs Async (Synchronous vs Asynchronous) :

	=> In a synchronous call, the client sends a request and waits for the response before continuing.
			Example:
			A standard REST API call:
				Service A ‚Üí calls Service B
				Service A waits
				Service B responds
				Service A continues
			Characteristics:
				Blocking
				Immediate response required
				Simple request‚Äìresponse pattern
				Tight coupling (Service A depends on Service B being available)
				
	=> In an asynchronous model, the client sends a message and does not wait for an immediate response.
			Example:
			Using a message broker like Apache Kafka or RabbitMQ:
				Service A publishes a message
				Service A continues immediately
				Service B processes the message later
			Characteristics:
				Non-blocking
				Event-driven
				Loose coupling
				Better resilience
				
	==> when to use Kafka/RabbitMQ(Async) :
		1. Decoupling services:
			Services should not fail just because another service is down.
			Example:
				Order Service publishes "OrderCreated"
				Inventory, Email, Billing consume it independently.
				
		2.High throughput / scalability
			Apache Kafka is especially good for:
				Millions of events
				Event streaming
				Real-time analytics
				Log aggregation
				
124. how do differ from @RestController, @Service, @Repository differ in terms of Application context ?
	=> All three:
		@RestController
		@Service
		@Repository
			=> Are Spring-managed components.
			=> they are detected during the component scanning and registred as beans in application context.
			
	1. @RestController : @Controller + @ResponseBody
			üìå Purpose
					Used in the web layer to handle HTTP requests.
					
			üì¶ What happens in ApplicationContext?
					Registered as a bean
					Registered with Spring MVC‚Äôs HandlerMapping
					Methods are mapped to HTTP endpoints
					Responses are automatically serialized (JSON/XML)
	2. @Service
			@Service is a specialization of @Component
			üìå Purpose
				Represents business logic layer.
				
			üì¶ What happens in ApplicationContext?
				Registered as a bean
				No additional behavior by default
				Used for semantic clarity
			
	3. @Repository
			Also a specialization of @Component
			=> But this one has extra behavior.

			üìå Purpose
				Represents data access layer.
			üì¶ What happens in ApplicationContext?
				Registered as a bean
				Automatically participates in PersistenceExceptionTranslation


125.  what are the components of Kafka ?
	üîπ Core Kafka Components :
	
	1. Producer :
		Publishes (writes) records to Kafka topics
		Responsible for:
			Choosing topic & partition
			Serialization
			Retries & acknowledgements.
			
	2. Consumer :
		Subscribes to topics and reads records
			Works in consumer groups
		Responsible for:
			Offset management
			Message processing
			
	3. Topic :
		A logical stream of data
		Identified by a name
		Data is written and read only via topics
		
	4. Partition :
			Topics are split into partitions
		Enables:
			Parallelism
			Scalability
			Each partition is an ordered, immutable log
			
	5. Broker
		Kafka server that:
			Stores data
			Serves producers & consumers
		=> A Kafka cluster has multiple brokers.
		
	6. Kafka Cluster :
		=> A group of brokers working together
		Provides:
			Load balancing
			Fault tolerance
			High availability
			
	7. Offset :
		A unique sequence number per partition
		Identifies a consumer‚Äôs position in the log
		
	8. Consumer Group :
		=> Logical group of consumers
		Kafka ensures:
			One partition ‚Üí one consumer in a group
			Enables horizontal scaling
			
	9. Replication :
		Each partition has replicas
			Leader replica
			Follower replicas
		=> Ensures fault tolerance
		
	10. Leader & Follower :
			Leader: Handles all reads/writes
			Followers: Replicate leader‚Äôs data
	
		
126. üîπ What are equals() and hashCode()?

	=> Both methods come from java.lang.Object and are heavily used by hash-based collections like HashMap, HashSet, Hashtable.
	
	| Method       | Purpose                                                         | return type |
	| ------------ | --------------------------------------------------------------- |	---------- |
	| `equals()`   | Checks **logical equality** (content comparison)                |	boolean     |
	| `hashCode()` | Helps Java **quickly locate objects** in hash-based collections |	int         |
	
	üëâ Rule:
	If two objects are equal according to equals(), they must have the same hashCode().
	
	=> üîπ How hashCode() works INTERNALLY üß†
			When you add an object to a HashMap / HashSet:
				Java calls hashCode()
				Hash code is converted into a bucket index
				Object is stored in that bucket
			
	=> üîπ How equals() works INTERNALLY üß†
			Used only when needed:
				Java first checks hashCode()
				If hashCodes are different ‚Üí objects are NOT equal
				If hashCodes are same ‚Üí Java calls equals()
			
		=> if (obj1.hashCode() == obj2.hashCode()) {
				obj1.equals(obj2);
			}
			
	üîπ Contract Between equals() and hashCode() üìú
			Java enforces this contract:
				1Ô∏è. If a.equals(b) is true
				‚û°Ô∏è a.hashCode() == b.hashCode() must be true

				2Ô∏è. If hashCode() is same
				‚û°Ô∏è equals() may be true or false

				‚ùå Breaking this contract causes bugs in HashMap / HashSet
				
	==> ‚úîÔ∏è Statement 1 : If equals() returns true, then hashCode() must be the same
	==> ‚úîÔ∏è Statement 1 : If two objects have the same hashCode, equals() may return true or false
	
	

127. üîπ Runnable vs Callable :

		| Feature      | Runnable | Callable |
		| ------------ | -------- | -------- |
		| Return value | ‚ùå No     | ‚úÖ Yes    |
		| Exception    | ‚ùå No     | ‚úÖ Yes    |
		| Method       | `run()`  | `call()` |


128. üîπ Core Components of ExecutorService üß†
		1Ô∏è. Task :
			Runnable ‚Üí no result
			Callable<V> ‚Üí returns result & can throw exception
			
		2. Thread Pool :
			A set of reusable worker threads
			Types:
				Fixed thread pool
				Cached thread pool
				Single thread executor
				Scheduled executor
				
		3. Task Queue :
				Holds tasks when all threads are busy
				FIFO by default
				
129. what is dead lock and How to AVOID Deadlock ‚úÖ (MOST IMPORTANT)

	=> A deadlock occurs when two or more threads are permanently blocked, each waiting for a resource held by the other
	
		üëâ None of the threads can proceed
		üëâ Application appears hung forever
		
	=> üîπ How to AVOID Deadlock ‚úÖ (MOST IMPORTANT)
	
	1. Use tryLock() (Timeout-based locking) :
	
		Lock lock1 = new ReentrantLock();
		Lock lock2 = new ReentrantLock();

		if (lock1.tryLock()) {
			try {
				if (lock2.tryLock()) {
					try {
						// work
					} finally {
						lock2.unlock();
					}
				}
			} finally {
				lock1.unlock();
			}
		}

	2. Minimize Lock Scope :
		synchronized(this) {
			// only critical code
		}
	
	3. Avoid Nested Locks (if possible) :
		synchronized(a) {
			synchronized(b) { }
		}

	4. Use Higher-Level Concurrency APIs :
		=> ExecutorService
		=> ConcurrentHashMap
		=> BlockingQueue
		
130. Can we synchronize constructor?
		=> A constructor‚Äôs job is to create and initialize an object.
		=> During constructor execution:
				The object is not fully created
				The monitor lock (this) does not yet exist safely
				No other thread can access the object until construction finishes
				
			=> So synchronization makes no sense here
			
		=> but, use a synchronized block inside constructor
		
131. üî• synchronized vs ReentrantLock :

	üîπ What is synchronized :
		=> synchronized is a Java keyword that provides implicit locking using the JVM‚Äôs intrinsic (monitor) lock.
		
		Eg:	synchronized void increment() {
				count++;
			}
			
		=> Lock is automatically acquired & released
		=> Simple and safe
		=> Managed entirely by JVM
		
	üîπ What is ReentrantLock :
		=> ReentrantLock is a class from java.util.concurrent.locks package that provides explicit locking with advanced features.
		
		Eg : Lock lock = new ReentrantLock();

			lock.lock();
			try {
				count++;
			} finally {
				lock.unlock();
			}
			
			=> Locking is manual
			=> More control
			=> More powerful

132. CompletableFuture vs @Async ?

	üîπ What is @Async?
			@Async is a Spring annotation used to run a method asynchronously in a separate thread.

		Eg :	@Async
				public void sendEmail() {
					// runs in background thread
				}

		üîç How it works internally
			=> Spring creates a proxy
			=> Method is submitted to a TaskExecutor
			=> Caller thread does not wait
			
	üîπ What is CompletableFuture?
			CompletableFuture is a Java 8 concurrency API for asynchronous programming with chaining.

			CompletableFuture
				.supplyAsync(() -> getUser())
				.thenApply(user -> user.getEmail())
				.thenAccept(System.out::println);

			üîç How it works
				=> Executes tasks asynchronously
				=> Supports non-blocking pipelines
				=> Can combine multiple async tasks
				

133. PUT vs PATCH :

		| Aspect      | **PUT**                 | **PATCH**                 |  PUT : If a field is missing ‚Üí it may be deleted or reset
		| ----------- | ----------------------- | ------------------------- |  PATCH : updates only specified fields
		| Purpose     | Replace entire resource | Partially update resource |		   Unmentioned fields remain unchanged
		| Update type | Full update             | Partial update            |
		| Idempotent  | ‚úÖ Yes                   | ‚úÖ Yes (usually)           |
		| Payload     | Complete object         | Only changed fields       |
		| Risk        | Can overwrite fields    | Safer for partial changes |
						
		üîπ REST Best Practices (Important)

		| Scenario             | Recommended |
		| -------------------- | ----------- |
		| Update full resource | PUT         |
		| Update single field  | PATCH       |
		| Toggle status        | PATCH       |
		| Reset entire object  | PUT         |
		

134. What is an Indexes ?

		üîπ What is an Index?
		=> An index is a data structure used by a database to quickly locate rows without scanning the entire table.
		
		
		üîπ Pros of Indexes ‚úÖ
			1. Faster SELECT Queries
			2. Faster Sorting & Filtering
			3. Faster JOIN Operations
			4. Enforces Uniqueness
			
		üîπ Cons of Indexes ‚ùå
			1. Slower INSERT / UPDATE / DELETE : Every data change must update indexes.
			2. Extra Storage Space :
				=> Indexes consume disk & memory
				=> Large tables ‚Üí large indexes
			3. Over-Indexing Hurts Performance
			4. Maintenance Cost
	
135. Simplest & Correct Interview Version of Overiding equlas() and hashCode()

	public class Employee{
		private int id;
		private String name;
		
		@Override
		public boolean equals(Object obj){
			if(this == obj){
				return true;
			}
			
			if(!(Obj isntance Employee)){
				return false;
			}
			
			Employee e = (Employee) obj;
			return id == e.id && name.equals(e.name);
		}
		
		@Override
		public int hashCode(){
			return id + name.hashCode();
		}
		
	}
	
	
136. SOLID is a set of 5 object-oriented design principles that help you build clean, maintainable, and scalable software:

	1. SRP ‚Äì Single Responsibility Principle : SRP means one class should handle one responsibility
	2. OCP ‚Äì Open‚ÄìClosed Principle : Classes should be open for extension but closed for modification
	3. LSP ‚Äì Liskov Substitution Principle : Objects of a subclass should be replaceable with objects of the superclass.
	4. ISP ‚Äì Interface Segregation Principle : Clients should not be forced to implement methods they do not use.
	5. DIP ‚Äì Dependency Inversion Principle : High-level modules should not depend on low-level modules. Both should depend on abstractions.
		
	
137. LSP Violation Example (Bird)  :

	‚ùå Wrong Design
		class Bird {
			void fly() { }
		}

		class Penguin extends Bird {
			@Override
			void fly() {
				throw new UnsupportedOperationException();
			}
		}

		Usage :
			Bird bird = new Penguin();
			bird.fly(); // üí• Runtime error

		üö® Penguin is not substitutable for Bird
		üö® Violates LSP


138. üßµ Thread Life Cycle in Java :

	=> In Java, a thread goes through several well-defined states during its lifetime. 
		These states are defined in the Thread.State enum.
	
	1. NEW :
		=> A thread is in the NEW state after it is created but before it is started.
		=> It has not yet begun execution.

		=> Thread t = new Thread();
			‚úî Thread object created
			‚ùå start() not called yet
		
	2. RUNNABLE :
		=> After calling start(), the thread moves to RUNNABLE.
		=> It is ready to run and waiting for CPU time.
		=> It may be running or ready to run (Java does not distinguish between ready and running).

		=> t.start();
			‚úî Eligible for execution
			‚úî Controlled by the thread scheduler
		
	3. BLOCKED :
		=> A thread enters BLOCKED state when it is waiting to acquire a monitor lock.
		=> Happens when trying to enter a synchronized block/method that is already locked by another thread.

			synchronized(obj) {
			   // critical section
			}

			‚úî Waiting for lock
			‚ùå Cannot proceed until lock is available
			
			
	4. WAITING :
		=> The thread waits indefinitely until another thread performs a specific action.
		=> Triggered by methods like:

			wait()
			join()
			LockSupport.park()

			‚úî No CPU usage
			‚úî Waiting for notification
			
	5. TIMED_WAITING :
		=> The thread waits for a specified amount of time.

		=> Triggered by:
			sleep(1000)
			wait(1000)
			join(1000)

			‚úî Waiting with timeout
			‚úî Automatically returns after time expires
			
	6. TERMINATED
		=> The thread enters TERMINATED after execution completes.
		=> It cannot be restarted.

			=> // run() method finishes

			‚úî Thread is dead
			‚ùå Cannot call start() again
			
	üéØ Important Notes :
		=> A thread can move between RUNNABLE ‚Üî BLOCKED/WAITING/TIMED_WAITING multiple times.
		=> Once in TERMINATED, it cannot restart.
		=> The thread scheduler controls execution order.
		
		
139. üî• Difference Between volatile and synchronized in Java ?

	‚úÖ  volatile :
			What it does:
				=> Ensures visibility of variable changes across threads.
				=> Prevents instruction reordering.
				=> Does NOT provide locking.
				=> Does NOT guarantee atomicity.

			Example:
				=> volatile boolean flag = false;

				If Thread A changes flag = true,
				Thread B immediately sees the updated value.

			‚ùå But This Is Not Safe:
				volatile int count = 0;
				count++;   // Not atomic!
				=> Still causes race conditions.
				
	‚úÖ synchronized :
			What it does:
			=> Provides mutual exclusion (locking).
			=> Ensures only one thread executes the block/method at a time.
			=> Guarantees visibility + atomicity.

			Example:
				synchronized void increment() {
					count++;
				}

				‚úî Thread-safe
				‚úî No race condition
				

140. If I want to write a thread safe code, what all things I should consider ?

	=> Writing thread-safe code is not just about adding synchronized. It‚Äôs about designing your code 
	   so that multiple threads can access shared data safely without causing race conditions, 
	   visibility issues, or deadlocks.
	   
	 ‚úÖ Identify Shared Mutable State (Most Important) :
			Ask yourself:
				=> Is this variable accessed by multiple threads?
				=> Can it change (mutable)?
				=> Is it read + written by different threads?
				
			üëâ If yes, it needs protection.
				eg: int count = 0;   // Shared + Mutable = Risky
				
				
	‚úÖ Prefer Immutability (Best Strategy) :
			=> Immutable objects are automatically thread-safe.

			Eg:	final class User {
					private final String name;
					private final int age;

					public User(String name, int age) {
						this.name = name;
						this.age = age;
					}
				}
				
				‚úî No setters
				‚úî All fields final
				‚úî No synchronization needed

			üí° Best practice: Make classes immutable whenever possible.
			
			
	‚úÖ Use Proper Synchronization for Shared Data :
			=> If multiple operations must happen together, use:
			‚úî synchronized
					synchronized(this) {
						count++;
					}

			‚úî Locks
					Lock lock = new ReentrantLock();
					lock.lock();
					try {
						count++;
					} finally {
						lock.unlock();
					}

			‚úî Atomic Classes
					AtomicInteger count = new AtomicInteger(0);
					count.incrementAndGet();
				
	‚úÖ Use volatile Only for Visibility (Not Locking) :
			=> Use volatile when:
				=> Only simple read/write
				=> No compound operations
			
			Good example:
			eg: volatile boolean shutdown;

			Bad example:
			eg:	volatile int count;
				count++;   // Still unsafe
				
	‚úÖ Avoid Deadlocks :
			Deadlock happens when:
				=> Thread A ‚Üí holds Lock1 ‚Üí waiting for Lock2
				=> Thread B ‚Üí holds Lock2 ‚Üí waiting for Lock1

			Prevention:
				=> Always acquire locks in the same order
				=> Keep synchronized blocks small
				=> Avoid nested locks when possible
				
	‚úÖ Minimize Scope of Synchronization :
			Bad:
			Eg:	public synchronized void method() {
					// 100 lines of code
				}

			Better:
			Eg:	public void method() {
					// non-critical code

					synchronized(this) {
						// only critical section
					}
				}

			‚úî Improves performance
			‚úî Reduces contention
			
	‚úÖ Prefer High-Level Concurrency Utilities :
			Instead of manual threads, use:
				=> ExecutorService
				=> ConcurrentHashMap
				=> BlockingQueue
				=> AtomicInteger
				=> CompletableFuture
			These are safer and more scalable.
			
			
141. visibility vs atomcity vs ordering ?

	üîç Visibility
		üëâ Meaning:
			When one thread updates a variable, will other threads see the updated value immediately?

		‚ùå Without Visibility Guarantee :
				=> Each thread may cache variables locally.
					eg:	boolean flag = false;

						Thread A:
						flag = true;

						Thread B:
						while (!flag) { }   // may loop forever


				=> Thread B may never see the update.

		‚úÖ How to Guarantee Visibility
				=> volatile
				=> synchronized
				=> Lock
				=> Atomic classes

					eg: volatile boolean flag;

				Now changes become visible to all threads immediately.
				
	‚öõ Atomicity
			üëâ Meaning:
					=> An operation happens completely or not at all (indivisible).
					=> No other thread can see it halfway.

			‚ùå Not Atomic
				count++;   // NOT atomic

				This is actually:
					=> Read
					=> Increment
					=> Write

			Two threads can interfere ‚Üí wrong result.

			‚úÖ Atomic Operations

				=> synchronized
				=> Lock
				=> AtomicInteger.incrementAndGet()

				Eg: AtomicInteger count = new AtomicInteger();
					count.incrementAndGet(); 
					
	üîÑ Ordering
		üëâ Meaning:
				=> The execution order of instructions may be rearranged (reordered) by:
					1. Compiler
					2. JVM
					3. CPU

		For performance optimization:
		
				=> Example of Reordering
						int a = 1;
						int b = 2;

				=> The CPU might execute:
						b = 2;
						a = 1;

				=> Single thread ‚Üí no problem
				=> Multiple threads ‚Üí can cause serious bugs
				

	=> üß† Summary Table :
	
		| Concept    | What It Solves                  | Example Tool                    |
		| ---------- | ------------------------------- | ------------------------------- |
		| Visibility | Other threads see latest value  | `volatile`                      |
		| Atomicity  | Operation cannot be interrupted | `synchronized`, `AtomicInteger` |
		| Ordering   | Prevent instruction reordering  | `volatile`, `synchronized`      |
		

142. üßµ What is a BlockingQueue in Java?

	=> A BlockingQueue is a thread-safe queue used in producer‚Äìconsumer scenarios where:
			üîπ Producers add elements
			üîπ Consumers remove elements
			üîπ Threads automatically wait (block) when needed
		=> It is part of Java‚Äôs concurrency utilities (java.util.concurrent).

	‚úÖ Why "Blocking"?
			Because operations block the thread when:
				1. Queue is empty ‚Üí take() waits
				2. Queue is full ‚Üí put() waits

			=> So you don‚Äôt need to manually use:
				1. wait()
				2. notify()
				3. synchronized
				
		Eg: BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(2);

				// Producer
				new Thread(() -> {
					try {
						queue.put(1);
						queue.put(2);
						queue.put(3); // waits (queue full) -> Queue size = 2
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}).start();

				// Consumer
				new Thread(() -> {
					try {
						Thread.sleep(2000);
						System.out.println(queue.take()); // removes 1 
					} catch (Exception e) {}
				}).start();


143. ReentrantLock vs readWriteLock ?

	| Feature                  | ReentrantLock   | ReadWriteLock          |
	| ------------------------ | --------------- | ---------------------- |
	| Lock type                | Single lock     | Two locks (read/write) |
	| Multiple readers allowed | ‚ùå No            | ‚úÖ Yes                |
	| Multiple writers allowed | ‚ùå No            | ‚ùå No                 |
	| Best for                 | General locking | Read-heavy systems     |
	| Complexity               | Simple          | Slightly complex       |
	

144. If I want to call third party API, what things I should consider

		=>  When calling a third-party API, I consider timeout configuration, error handling, 
			retries with backoff, circuit breaker, rate limiting, security (authentication), 
			proper logging/monitoring, and validation of responses to prevent cascading failures.
			
			
145.  We have a list of integers. Find out all the numbers starting with 1 using stream function
	
		Eg: List<Integer> numbers = Arrays.asList(10, 123, 415, 1567, 89, 1002, 91);

        1. List<Integer> collect = numbers.stream().filter(n -> String.valueOf(n).startsWith("1")).collect(toList());
           System.out.println(collect);    
		
        2. System.out.println(numbers.stream().filter(n -> String.valueOf(n).contains("1")).collect(toList()));
		

146. üéØ Calculate Average Salary by Gender :
		
		System.out.println(list.stream().collect(Collectors.groupingBy(Employee::getGender,
                Collectors.averagingDouble(Employee::getSalary)
                )));
				

147. Write a java program to find sum of even numbers and sum of odd numbers in a given list using java 8 streams.
		
		List<Integer> numbers = Arrays.asList(10, 123, 45, 1567, 89, 1002, 9);

        Map<Boolean, List<Integer>> collect = numbers.stream().collect(partitioningBy(n -> n % 2 == 0));
        System.out.println(collect.get(true));

        System.out.println(numbers.stream().filter(n-> n%2 == 0).reduce(0, (a,b) -> a+b));

        System.out.println(numbers.stream().filter(n-> n%2 == 0).mapToInt(Integer::intValue).sum());
		
	
148. compare the two array and order doesn't matter and handle duplicates

	Eg:	1: 1int[] arr1 = {1, 2, 3, 4};
			int[] arr2 = {4, 3, 2, 1};

			Arrays.sort(arr1);
			Arrays.sort(arr2);
			System.out.println(Arrays.equals(arr1, arr2));


	//      If You Don't Want to Modify Original Arrays
	
			int[] copy1 = arr1.clone();
			int[] copy2 = arr2.clone();

			Arrays.sort(copy1);
			Arrays.sort(copy2);
			
steams	2. System.out.println(Arrays.stream(arr1)
                    .sorted()
                    .boxed()
                    .collect(Collectors.toList())
                        .equals(Arrays.stream(arr2)
                                .sorted()
                                .boxed()
                                .collect(Collectors.toList())));
								
		3. ‚úî Use Set
				Set<Integer> set1 = Arrays.stream(arr1).boxed().collect(Collectors.toSet());
				Set<Integer> set2 = Arrays.stream(arr2).boxed().collect(Collectors.toSet());

				boolean isEqual = set1.equals(set2);
				
149.  Remove all the special char in given string

	        String s1 = "abc@#12!bn";

	    Eg:1    for (int i = 0; i < s1.length(); i++) {
					if(Character.isLetterOrDigit(s1.charAt(i))){
							System.out.println(s1.charAt(i));
						}
				}
	
		Eg:2	String s2 = s1.replaceAll("[^a-zA_Z0-9]","");   if '^' remove o/p: @#! 
				System.out.println(s2); //abc12bn
				
150. Java 8 Program to get Highest paid Employee in Each department using stream api ?

		System.out.println(list.stream()
			.collect(Collectors.groupingBy(Employee::getDept
				,Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparing(Employee::getSalary))
				,Optional::get))));



==============================================================

Round 2:
1). Angualr and javascript coding questions :	

1. Create a custom validators to check pass strength
	Eg : this.userGroup = this.fb.group({
			username  : ['', Validators.required, Validators.pattern("")],
			password : ['', [this.strongPasswordValidator()]]
		})
		
		 strongPasswordValidator(){
			return (control: AbstractControl)=> {
			  const value = control.value;
			  if(!value){
				return null;
			  }

			  const strong = 
			  /[A_Z]/.test(value) &&
			  /[a-z]/.test(value) &&
			  /[0-9]/.test(value) &&
			  value.length >= 8;

			  return strong;

			};
		}
		
2. How do you add FormControls dynamically?  coding later

3. How to auto populate form data from api

	=> this.form.patchValue(apiResponse) 
	
	=> Method			Behavior
	   setValue			Requires all fields
	   patchValue		Partial update allowed
	
4. How to reset the form but keeping default values ?
	=> this.form.reset({
		county : "India";
	})
	
5.	|Operator  | Use Case             |
	| --------- | ----------------------- |
	| switchMap | Search box autocomplete |
	| mergeMap  | Parallel API calls      |
	| concatMap | Ordered API execution   |
	
6. How to cancel prvious HTTP call when typing into input box

	=>  this.searchBox.valueChnages.pipe(
		debounrcTime(300),
		switchMap(value => this.api.search(value)),
		).subscribe();
		
7. Handle API error without breaking stream

	=> pipe(
		catchError(err-> {
			return of([]);
		})
	)
	
8. Share API result across the components => get coding the chatGPT
	shareReply() 
	
9. How do you manage shared state withiut NgRx ?

	=> private dataSubject = new BehaviorSubject(null);
	=> data$ = this.dataSubject.asObservable();

	=> setData(val : any){
		this.dataSubject.next(val);
		}
		
	| Subject                    | BehaviorSubject     |
	| -------------------------- | ------------------- |
	| No initial value           | Needs initial value |
	| Late subscribers miss data | Gets last value     |
	
10. How does NgRX works internally ?
	=> Component ‚Üí Action ‚Üí Reducer ‚Üí Store ‚Üí Selector ‚Üí Component

11. How to create custom directive for allowOnlyNumbner in input

	=> @HostListener('input', ['$event'])
		onInput(event:any) {
		  event.target.value =
			event.target.value.replace(/[^0-9]/g,'');
		}
	
	=> <input type="text" appOnlyNumber placeholder="Enter numbers only">
	
12.HighLight element color on Hover

	=> @HostListerner('mouseenetr')
		onEnter(){
			this.el.nativeElement.style.background = 'yellow';
		}
		
13. custom pipe to transform date as DD/MM/YYYY
	=> @Pipe({
		name : 'customDate'
	   })
	    export class customPipe implements PipeTransform{
			transform(value: any) {
				const d = new Date();
				return `${d.getDate}/${d.getMonth}/${d.getFullYear};`
			}
		}
		
	=> {{ today | customDate }}
	
14. Example for @output()
		
	=> @Output() messageEvent = new EventEmitter();
	   sendData(){
		this.messageEvent.emit("Hello parent!")
	   }
	   
	   <app-child (messageEvent)="receiveMessage($event)"></app-child>
	   
	   => in child component
		receiveMessage(data:String){
			console.log(data);
		}
		
15. load component dynamically on button click

	=> @ViewChild('container', {read:ViewContaierRef})
		container! : ViewContaierRef;
		
		load(){
			this.concatiner.createComponent(UserComponent)
		}
16. track By examples
	=> <div *ngfor="let item of items; trackBy:trackId"></div>
	
	=> trackId(index:number, item:any){
			return item.id;
	   }
	   
17. form value changes causing multiple apis call - how to fix
	
	=> deBpunceTime
	=> distnctUntillChange
	
18. dashboard hits the same API 5 times > - how to fix
	=> this.http.get().pipe(
		shareReplay(1);  
	)
	=> shareReplay will caches the last emmision value and prevents the dupliacte HTTP executions
	
	
19. App becomes slow after navigate the multiple pages
	=> data$ = new Subject();
	
		onDestroy(){
			this.data$.complete();
		}
		
		
20. UI Not Updating After API Response
	=> Because of UI doesnt't refresh
		=> onPush changeDetection + mutated Object
		
		Eg: this.user.name = "Roy"  ‚ùå Wrong
			this.user = {...this.user, name:'Roy'}; ‚úÖ Correct
			
21. API flooding ?
	=> typing search box send api request for every key press
	
		Eg : valueChnages.pipe(
			debounrcTime(300),
			distinctUntilChnage(),
			switchMap(val -> api.search(val))
		)

22. API Race Condition Bug
	=> user switch filter faster -> wrong data appears
		
	‚úÖ Fix => use switchMap (cancel previous request)
	
23. Dynamic Component Memory Leak

	=> container.destroy()
	
24. Micro Frontend Angular App Communication
	=> custom events
	=> shared Store
	=> shared service worker
	
25. switchMap Output
	of(1,2,3).pipe(
		switchMap(val -> val * 10);
	).subscribe( val -> console.log(val))
	
	
26. dynamic form fields
	=> this.form.push(
		new FomrControl('',[]);
		)
		
27. Global Error Handling using HTTp interceptor
	=> intercept(req,next){
		return next.handle(req).pipe(
			catchError(err-> {
				alert("something went wrong!")
				return throwErr(err)
			})
		)
	}
	
28. how do you expose and consume and communicate Api ?
	=> Using Rest Controllers we are exposing APIs
	
	=> Using RestTemple, webclient, Feign Client we consume API
	
	=> communication 2 ways -> sync and async
	
29. DIff between RestTemplate and Webclient
	
	Rest Template = Request ‚Üí Thread waits ‚Üí Response arrives ‚Üí Continue
	Web Client = Request ‚Üí Thread free ‚Üí Response callback ‚Üí Process

	
	
30. DDL v/s DML real time use case	

	=> DDL (Data Definition Language) is used to define or modify database structure (schema).
	
	| Command  | Purpose                             |
	| -------- | ----------------------------------- |
	| CREATE   | Create table/database               |
	| ALTER    | Modify table structure              |
	| DROP     | Delete table                        |
	| TRUNCATE | Remove all rows (structure remains) |
	
	DML (Data Manipulation Language) is used to manipulate actual table data.
	
	| Command | Purpose     |
	| ------- | ----------- |
	| INSERT  | Add data    |
	| UPDATE  | Modify data |
	| DELETE  | Remove data |
	| SELECT  | Fetch data  |


	
	
31. Views, procedures, triigers

	üëâ What is a View?
	=> These are used to fetch the data from table, a vtirual table can be created using sql queries.
	=> not used to store only fetch
	
	üëâ What is Stored Procedure?
	=> A Stored Procedure is a precompiled block of SQL logic stored in database.
	
	üëâ What is Trigger?
	=> A Trigger is SQL block of code that automatically excute when an event accurs
		Events:
			INSERT
			UPDATE 
			DELETE
			

32. Where does the Kafka stores the data ?

	=> kafka stores the data on the disk(file system) of the Kafka Broker servers.
	
	Internally 
	-> Each Topic -> split into Partition
	-> Each Partion -> stored as log files on disk
	
	=> Kafka is disk-based (not memory based like Redis)
	
	
33. How does Kafka maintain version ?

	=> Kafka does not use the work version -> it uses Offset
	=> Each message has a unique sequentail offset number
	Eg:
		Partition-0
		--------------
		Offset 0 ‚Üí Order Created
		Offset 1 ‚Üí Payment Done
		Offset 2 ‚Üí Order Shipped
		
		=> Kafka knows which message alreay consumed and what is next
		
34. How long does kafka keep data ?
	
	=> Kafka keeps the data based on Retention policy:
		2 types 
			1. Time based retention -> can configured -> eg: log.retention.hours = 168  ->  once 168 hours done -> Old segments are deleted automatically
			2. size based retention -> can configured -> eg: log.retention.bytes = 10GB ->  If topic exceeds 10GB ‚Üí old data deleted
			
	
35. Kafka Architecture :

	Producer
		‚Üì
	Kafka Broker (Disk Storage)
		‚Üì
	Consumer

36. how does kafka handle backup/safety ?
	=> Replication factor
		-> replication.factor = 3
		
		| Question                | Answer                       |
		| ----------------------- | ---------------------------- |
		| Where stored?           | Broker disk (log segments)   |
		| How version maintained? | Using OFFSET                 |
		| How long stored?        | Retention policy (time/size) |
		| Physical location?      | Broker server file system    |
		| Backup?                 | Replication factor           |
		
	=> when you'll get memory execption in kafka ?
			1. Broker-Side Memory Issues (Most Critical)
			
				‚ùå Huge Message Size -> Producer sends messages larger than broker limits
				‚ùå Too Many Partitions -> ~2,000‚Äì4,000 partitions per broker (depends on RAM)
				‚ùå High Fetch/Produce Throughput -> Large batches + slow disk/network
				
			2. Consumer-Side Memory Exceptions
				-> Too many records loaded into memory at once
			3. Log Retention & Disk Backpressure
		
37. which design pattern you worked on ?
	üîπ 1) Singleton Design Pattern (Most Common)
		=> In Spring, Beans are Singleton by default.
		
				Example:  Spring creates only one object of this class and reuses it.
				
					=> Service classes
					=> Repository classes
					=> Configuration classes
					=> Utility classes

	üîπ 2) Factory Design Pattern (Very Important)
		=> Used when object creation logic should be hidden.
		=> We used Factory pattern to create different service implementations dynamically.
		
				Example:
					In your project:
						üëâ Payment Service
						üëâ Notification Service
						üëâ Report Generator
						
	üîπ 3) Builder Design Pattern
			
		=> Used when object has many fields.
		
				Example:
					DTO / Request Object creation
					User user = User.builder()
						.name("Roy")
						.age(25)
						.city("Bangalore")
						.build();
						
	üîπ 5) Observer Pattern
		=> Used in:
			Kafka consumers
			Event listeners
			Spring Application Events
			
			Example:
				Producer publishes event
				Multiple consumers listen to it.

38. what is volatile key word ? can valatile ensure thread safety ?

	==> The valatile keyword ensure visbility of changes to varible across threads.
	==> Note :  No guarrantee thread safety or atomicity
		
		
39. ‚úÖ What is AWS Lambda ?

	==> AWS lambda is serverless compute service by AWS, that let's you run code without managing servers
	
	==> You only:
	
			=> Upload your code
			=> Configure a trigger
			=> AWS automatically handles scaling, provisioning, patching, and infrastructure
			
	==> üîó How AWS Lambda Integrates With Other AWS Services
	
			==> AWS Lambda is event-driven, meaning it is triggered by other AWS services.
				 
				Eg : Client ‚Üí API Gateway ‚Üí Lambda ‚Üí Response
					 File Upload ‚Üí S3 Event ‚Üí Lambda
				 
40. ‚úÖ What are Runnable and Callable Interfaces in Java?

	==> üëâ YES ‚Äî Both Runnable and Callable are Functional Interfaces ‚úÖ
	
	==> Runnable : void run();
	
			üìå Key Points
				‚úî Does NOT return result
				‚úî Cannot throw checked exception
				‚úî Used with Thread class or ExecutorService
				‚úî Old and simple interface
				
			Eg : class MyTask implements Runnable {
					public void run() {
						System.out.println("Task running...");
					}
				}

				public class Main {
					public static void main(String[] args) {
						Thread t = new Thread(new MyTask());
						t.start();
					}
					}
	==> Callable Interface : V call() throws Exception;
	
			üìå Key Points
				‚úî Returns a result
				‚úî Can throw checked exception
				‚úî Used with ExecutorService
				‚úî Introduced in Java 5
				
				
41. ‚úÖ What is Intrinsic Lock in Java?

	==> An intrinis lock is the internal moniter lock that every java object has, 
		which automatically aquired and released when a tread enters and exit syncronized block
		
		EG : üß† Key Points
				‚úî Every Java object has one intrinsic lock
				‚úî Managed automatically by JVM
				‚úî Used by synchronized
				‚úî Only one thread can hold it at a time
				‚úî Ensures mutual exclusion + visibility
				
	==> class Counter {
	
			public synchronized void increment() {
					System.out.println("Thread safe operation");
				}
			}
			
			When thread enters increment():
			üëâ Acquires intrinsic lock of Counter object (this)
			üëâ Executes method
			üëâ Releases lock after completion

42. ‚úÖ What is Race Condition?
	==> A race condtion happens when multiple threads compete to update shared data without proper synchronization,
		causing unpredicatble output
		
	==> to avoid this we can synchronized keyword 
		Eg :
		public void increment() {
			synchronized(this) {
				count++;
			}
		}
		
43. End-to-end flow of how an Entity class eventually becomes a table in the database (JPA ‚Üí Hibernate ‚Üí SQL)

	==> When Spring Boot starts, it scans entity classes and passes metadata to Hibernate through JPA. 
		Hibernate generates SQL based on entity mappings and ddl-auto configuration, 
		and executes it via JDBC to create database tables.

	
44. üß† Internal Working for @Repository

	==> It:
		1Ô∏è. Creates proxy around class
		2Ô∏è. Adds exception translation interceptor
		3Ô∏è. Catches DB exceptions
		4Ô∏è. Converts to Spring standard exceptions
		
		
45. What happens if both @Service and @Repository are used on the same class
		
		@Service
		@Repository
		public class UserServiceRepository {
		}

	==> | Aspect                | Result                         |
		| --------------------- | ------------------------------ |
		| Bean Creation         | One bean only                  |
		| App Crash             | ‚ùå No                           |
		| Exception Translation | ‚úÖ Yes (because of @Repository) |
		| Recommended           | ‚ùå No                           |
		
		
46. Why ConcurrentHashMap exists and when to use it ?
	==> ‚úÖ Why ConcurrentHashMap Was Introduced

			To provide:
			‚úî Thread safety
			‚úî High concurrency
			‚úî Better performance
			‚úî Lock-free reads
			‚úî Fine-grained locking
			
47. Global exception handler

	@RestControllerAdvice
	public class GlobalExceptionHandler {

		@ExceptionHandler(Exception.class)
		public ResponseEntity<String> handleGenericException(Exception ex) {

			return new ResponseEntity<>(
					"Internal Server Error",
					HttpStatus.INTERNAL_SERVER_ERROR
			);
		}
	}


========================================

	=== Java script ============

1. 	console.log('A');
	setTimeout(() => console.log('B'), 0);
	Promise.resolve().then(() => console.log('C'));
	console.log('D');
	
	o/p: A, D, B, C
	
2. for(var i=0;i<3;i++){
		setTimeout(() => console.log(i), 1000);
	} // 3,3,3,   but If use let it will become local variable 1,2,3
	
	
3. how do you use this inside Object'
	=> const obj = {
		name : "manju",
		getName(){
		return console.log(this.name);
	  }
	}
	obj.getName();
	
	
4. How to write api without Http
	Eg: fetch("")
		.then(
			res => console.log(res)
		)
		.catch(err-> {
			console.log(err)
		})
		
5. PromiseAll() -> It will take array of promise and return single promise out of it 
	let p1 = Promise.resolve(10);
	let p2 = Promise.resolve(12);
	let p3 = Promise.resolve(15);

	Promise.all([p1,p2,p3]).then(
	  res => console.log(res) // [10,12,15]
	).catch(err => {
	  console.log(err);
	})
	
	if one of the promise faile Eg: let p2 = Promise.reject(12);
	=> it will go to error section and print only 12
	
6. const arr = [1, [2, [3, 4]], 5];

	function flattenArray(array){
	  let result = []
	  array.forEach(element => {
		if(Array.isArray(element)){
		   result = result.concat(flattenArray(element));
		}else{
		  result.push(element)
		}
	  });
	   return result;
	}
	console.log(flattenArray(arr)); //[1,2,3,4,5]
	
7. remove duplicate key's object in given array
	=> let arr = [
		 {id:1,name:'A'},
		 {id:2,name:'B'},
		 {id:1,name:'C'}
		]
		
		let newMap = new Map();
		arr.forEach(item => {
			if(!newMap.has(item.id)){
				newMap.set(item.id, Item)
			}
		})
		
		console.log(Array.from(newMap.values()))
	 
	


2. Stream API questions :

1. String str = "this is a test. This test is only a test." Output: [test=3, is=3, this=2, a=2, only=1] using java 8 stream api

	=> solution : String str = "this is a test. This test is only a test.";
			      Map<String, Long> collect = Arrays.stream(str.split(" ")).collect(groupingBy(Function.identity(), counting()));

	
	

2. String input = "swiss";

	==> solution :
			String input = "swiss";
			String s = Arrays.stream(input.split("")).collect(groupingBy(Function.identity(), counting())).entrySet().stream().filter(n -> n.getValue() == 1).map(Map.Entry::getKey).findFirst().orElse("");
			System.out.println(s);

 
3. Collectors.groupingBy() and Collectors.partitioningBy()?

4. String input="a-1,b-2,c-3,a-4,b-5,c-6,a-7";
 
	o/p	a[1, 4, 7]
		b[2, 5]
		c[3, 6]
		
	=> solution : Map<String, List<Integer>> collect = Arrays.stream(input.split(","))
                .map(n -> n.split("-"))
                .collect(groupingBy(key -> key[0], mapping(key -> Integer.parseInt(key[1])
                        , toList())));

        System.out.println(collect);
		
 
5.Streams question to solve on Arrays.asList("Pen", "Eraser", "Note Book", "Pen", "Pencil", "Stapler", "Note Book", "Pencil"); -- find the string which are repeated multiple times

	        Set<String> repeatedVlaues = new HashSet<String>();
			List<String> list = items.stream().filter(item -> !repeatedVlaues.add(item)).toList();
			System.out.println(list);

6. int arr[] = {4,5,6,7,0,1,2} target value =0
		1. use rotate and Sorting.
		2. And After only find zero value position.
		3. What is the pivot value in here.
		4. find the mid index value.
		these 4 are related to that program.
		
		
	1. Solution : System.out.println(Arrays.stream(arr).min().orElseThrow());
	
	Mid index value:
	
		=> Arrays.stream(arr).skip(arr.length/2).findFirst().orElseThrow();
	
	
7. Increase sal by 20% who are in HR dept
	EMP - EMPID,EMPNAME
	DEPT - DEPTID,DEPTNAME
	EMP_DEPT - EMPID,DEPTID
	EMPSAL - EMPID,SAL
	
	=> solution :
		  List<Employee> list = Arrays.asList(
                new Employee("abc", 1000, "male", "3"),
                new Employee("xyz", 3000, "female", "5"),
                new Employee("pqr", 2000, "male", "4")
        );
        System.out.println(list.stream().filter(n-> n.getDept.contains("IT)).map(n -> n.getSalary() * 1.2).collect(Collectors.toList()));
		
	
8. To find dept name which has employee getting highest salary.

		     List<Employee> list = Arrays.asList(
                new Employee("abc", 1000, "male", "3", "IT"),
                new Employee("xyz", 3000, "female", "5","HR"),
                new Employee("pqr", 2000, "male", "4","Dev")
        );

        System.out.println(list.stream().max(Comparator.comparing(Employee::getSalary)).map(Employee::getDept).orElse(""));


9. Java Program to figure out sum of second lowest and second highest number from an Array

	Solution :	List<Integer> numbers = List.of(5, 1, 9, 2, 8, 3);
        Integer collect = numbers.stream().distinct().sorted().collect(collectingAndThen(toList(), a -> a.get(1) + a.get(a.size() - 2)));

10. I want to filter the employee list based on the dept_name.
	solution :  List<Employee> collect = list.stream().sorted(Comparator.comparing(Employee::getDept)).collect(toList());

11. In the Java layer, I want to filter the employee list using the Stream API, selecting only those with experience of 3, 5, or 7 years.

	solution :  List<Employee> collect  = list.stream().filter(n-> n.getExp() == "3" || n.getExp() == "5")
                .collect(Collectors.toList());
				

12. List<String> list = Arrays.asList("java", "spring", "JavaScript", "core java", "python");

	Solution : List<String> collect = list.stream().filter(n-> n.toLowerCase().contains("java")).collect(Collectors.toList());
	
13. nput - [1,3,2,3,4,5,5,1,5,5,6]
		output - 
		1-2
		3-2
		5-4
		
	Solution : Map<Integer, Long> collect = list.stream().collect(groupingBy(Function.identity(), counting()));
	

14.. List<Integer> list = Arrays.asList(2,17,5,17,20,2); -> get the lis of duplicate element into new array

	Solution :   Set<Integer> set = new HashSet<>();
				 List<Integer> collect = list.stream().filter(n -> !set.add(n)).collect(toList());
				 
				 
15. .int[] array = {1, 2, 4, 4, 5, 6, 2, 3, 4, 3, 4, 6}; Find The frequency of each number using stream api

Solution : Map<Integer, Long> collect = list.stream().collect(groupingBy(Function.identity(), counting()));


16. print number 1 - 100 withut for loop

		    static int n = 1;
			public static void main(String[] args) {
				printNumbers();
			}

			public static void printNumbers(){

				if(n > 10){
					return;
				}
				System.out.println(n++);
				printNumbers();
			}
			
			
17. find the third highest number in given list

	    List<Integer> list = List.of(1,4,2,6,8,4,8,7,4,9);
        Integer num = list.stream().distinct().sorted(Comparator.reverseOrder()).skip(2).findFirst().orElse(0);
        System.out.println(num);
		
		
18. get the 3rd Higest salary in given EMployee Object

       Optional<Integer> first = list.stream().map(Employee::getSalary).distinct().sorted(Comparator.reverseOrder()).skip(2).findFirst();
       System.out.println(first);
	   
19. Remove duplicates Employee based on salary
	
	  List<Employee> list = Arrays.asList(
                new Employee("manju", 5000, "male", "3", "IT"),
                new Employee("Teju", 5000, "female", "2", "DEV"),
                new Employee("Ram", 2000, "male", "7", "QA"),
                new Employee("Ram", 7000, "male", "7", "QA"),
                new Employee("Ram", 9000, "male", "7", "QA")
        );

       list.stream().collect(toMap(Employee::getSalary, e-> e, (e1,e2)-> e1)).values().stream().toList();

20. Find and print duplicate numbers in a list

		  List<Integer> list = List.of(1,4,7,9,3,5,7,2,2);
		  
	    List<Integer> collect = list.stream().collect(groupingBy(Function.identity(), counting()))
                .entrySet().stream().filter(n -> n.getValue() > 1)
                .map(n -> n.getKey()).collect(toList());

        System.out.println(collect);
		
		
21. Partition numbers into even and odd using streams

	    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Map<Boolean, List<Integer>> collect = numbers.stream().collect(partitioningBy(n -> n % 2 == 0));
        System.out.println(collect.get(false));
        System.out.println(collect.get(true));



22. Filter palindrome words from a list using streams

      List<String> words = Arrays.asList("madam", "racecar", "hello", "level", "world", "radar");
        List<String> collect = words.stream().filter(word -> isPalindromeWord(word)).collect(toList());
        System.out.println(collect);
		}

		public static  boolean isPalindromeWord(String word){
			String reversed = new StringBuffer(word).reverse().toString();
			return word.equals(reversed);
		}
		
23. Sort employees by name using streams

		  list.stream().sorted(Comparator.comparing(Employee::getName, String.CASE_INSENSITIVE_ORDER)).forEach(n->
               System.out.println(n.getName()));
			   
24. Sort employees by name and salary using streams

	    List<Employee> collect = list.stream().sorted(Comparator.comparing(Employee::getName, String::compareToIgnoreCase).thenComparing(Employee::getSalary)).collect(toList());
        collect.forEach(n-> System.out.println(n.getName()));
		
25. Find the average salary in each department

	    Map<String, Double> collect = list.stream()
                .collect(groupingBy(Employee::getDept, averagingInt(Employee::getSalary)));
        System.out.println(collect);
		
26. Find highest and lowest paid employee in each department

	min => Map<String, Employee> collect = list.stream().collect(groupingBy(Employee::getDept, collectingAndThen(minBy(Comparator.comparing(Employee::getSalary)), Optional::get)));
        collect.forEach((n,n1) -> System.out.println(n + " " + n1.getName() ));
		
	max =>list.stream().collect(Collectors.groupingBy(Employee::getDept, Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparing(Employee::getSalary)),Optional::get)));
	

27. Group names by first letter and count them

        Map<Character, Long> result =
                list.stream()
                        .collect(Collectors.groupingBy(
                                obj -> Character.toUpperCase(obj.getName().charAt(0)),
                                Collectors.counting()
                        ));

        System.out.println(result);

28. Fetch employee names based on department
	     Map<String, List<String>> collect = list.stream()
                .collect(Collectors.groupingBy(Empolyee::getDept,Collectors.mapping(Empolyee::getName,Collectors.toList())));

        System.out.println(collect); // {Dev=[pqr], HR=[xyz], IT=[abc]}

29. Find employees earning the same salary
	 Map<Integer, List<Empolyee>> collect = list.stream()
                .collect(Collectors.groupingBy(Empolyee::getSalary));

    System.out.println(collect); //{2000=[entity.Empolyee@4f023edb, entity.Empolyee@3a71f4dd], 3000=[entity.Empolyee@7adf9f5f], 1000=[entity.Empolyee@85ede7b

3. ================================ DSA =================================================

1. move all zoros at the end and sort remaing elements in ascending order

	=> int[] arr = {22, 12, 45, 0, 0, 60, 0};
			int j = 0;
			
			 for (int i = 0; i < arr.length; i++) {
				if(arr[i] != 0){
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
					
					j++
					
				}
			 }
			 
			 Arrays.sort(arr,0,j)
			 
			 (or)
			 
			int[] arr = {22, 12, 45, 0, 0, 60, 0};
			int[] newArray = new int[arr.length];
			int k = 0;
			for (int i = 0; i < arr.length; i++) {
				if(arr[i] != 0){
					newArray[k++] = arr[i];
				}
			}
			Arrays.sort(newArray, 0, k);
			Arrays.stream(newArray).forEach(n-> System.out.println(n));
			
			 
2. get all the substring in given string
	  String s1 = "ABC";
        
        for (int i = 0; i < s1.length(); i++) {
            for (int j = i+1; j <= s1.length(); j++) {
                System.out.println(s1.substring(i,j));
            }
        }
		
3. get only duplicates in given strings

	  String s1 = "ABC";
      String s2 = "ADC";

        System.out.println(Arrays.stream(s1.concat(s2).split(""))
                .collect(Collectors.groupingBy(Function.identity(),Collectors.counting()))
                .entrySet()
                .stream()
				.filter(n-> n.getValue() > 1)
                .map(n-> n.getKey())
                .collect(Collectors.joining()));
				
4. Find the vowels count

	 String s = "manju";
              List<Character> list = List.of('a','e','i','o','u');

                int count  = 0;
                for (int i = 0; i < s.length(); i++) {
    
                    char ch = toLowerCase(s.charAt(i));
                    if(list.contains(ch)){
                        count ++;
                    }
                }

                 System.out.println(count);
				 
		(or)
		
		String s = "manju";
        List<Character> vowels = List.of('a','e','i','o','u');
        List<String> newList = Arrays.stream(s.split(""))
                .filter(n -> vowels.contains(n.charAt(0))) // n.charAt(0) -> will convert string to char to compare with each vowels
                .collect(Collectors.toList());
        System.out.println(newList);

	
	
5. frequency of char in given string without streams
	 String s = "manjunath";
              Map<Character, Integer> map = new HashMap();
                for (int i = 0; i < s.length(); i++) {
                    map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0)+ 1);
                }
                System.out.println(map);
				
	=> with streams	
		  System.out.println(Arrays.stream(s.split("")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting())));
				
6. remove duplicates from given array

		int[] array = {10,20,30,10,40,50,20};
        System.out.println(Arrays.stream(array).distinct().boxed().collect(Collectors.toList()));
		
7. leap year 

	int year = 2024;

        if( (year % 400 == 0) || (year % 4 == 0 ) && (year % 100 != 0)){
            System.out.println("leap year");
        }else{
            System.out.println("No a leap year");
        }
		
8. count accurance of char in string
	        String s = "programming";
			char ch = 'g';
			int count = 0;

			for(char item : s.toCharArray()){
			   if(item == ch){
				   count++;
			   }
			}
			
			System.out.println(count);

9. sum of givem number
	  int num = 12345;
        int sum = 0;
        while (num!= 0){
            int digit = num %10;
            sum = sum + digit;
            num = num/10;
        }
        System.out.println(sum);
		
	=> with stream
	
		int num = 12345;
        int sum = Arrays.stream((String.valueOf(num).split(""))).mapToInt(Integer::parseInt).sum();
        System.out.println(sum);
	
10. find the sum of given array or number

	    List<Integer> list = List.of(10,20,40);
        System.out.println(list.stream().mapToInt(Integer::intValue).sum());

        int arr[] = {10,20,40};
        System.out.println(Arrays.stream(arr).boxed().mapToInt(Integer::intValue).sum());

        int num = 12345;
        System.out.println(Arrays.stream(String.valueOf(num).split("")).mapToInt(Integer::parseInt).sum());
		
11. sort the number Array method or streams

	    int arr[] = {10,5,20,60,40};
		Arrays.sort(arr);
        System.out.println(Arrays.stream(arr).boxed().sorted().collect(Collectors.toList()));
		
12. Merge two array using Strams

	 int[] arr1 = {1, 2, 3};
        int[] arr2 = {4, 5, 6};

        int[] array = IntStream.concat(
                Arrays.stream(arr1),
                Arrays.stream(arr2)
        ).toArray();
		
13. find the maximun occuring of char in given string
	String s = "manjunath";
    Map<Character, Integer> map = new HashMap<>();

    for (char ch : s.toCharArray()){
        map.put(ch, map.getOrDefault(ch,0) + 1);
    }

        System.out.println(map);


        char maxChar = ' ';
        int maxCount = 0;

        for(Map.Entry<Character, Integer> entry : map.entrySet()) {

            if(entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                maxChar = entry.getKey();
            }
        }

        System.out.println("Max occurring char: " + maxChar);
        System.out.println("Count: " + maxCount);
		
		
14.   int arr[] = {2,17,11,7}; // target=9

        for (int i = 0; i < arr.length; i++) {

            for (int j = i+1; j < arr.length; j++) {

                if(arr[i] + arr[j] == 9){
                    System.out.println(arr[i]  + " " + arr[j]);
                }
            }

        }

15. add array element one after other in new array

		int arr1[] = {1,2,3,4,5};
        int arr2[] = {6,7,8};

        int arr3[] = new int[arr1.length + arr2.length];

        int i = 0, j=0, k=0;

        while (i < arr1.length && j < arr2.length){
            arr3[k++] = arr1[i++];
            arr3[k++] = arr2[j++];
        }

        // Copy remaining elements (if any)
        while(i < arr1.length){
            arr3[k++] = arr1[i++];
        }

        while (j < arr2.length){
            arr3[k++] = arr2[j++];
        }

        Arrays.stream(arr3).forEach(n-> System.out.println(n)); //[1, 6, 2, 7, 3, 8, 4, 9, 5]
		
		(or)
		
		int arr1[] = {1,2,3,4,5};
        int arr2[] = {6,7,8};

        List<Integer>  list = new ArrayList<>(arr1.length + arr2.length);
        int i=0, j=0;
        while (i < arr1.length && j < arr2.length){
            list.add(arr1[i++]);
            list.add(arr2[j++]);
        }
        list.forEach(n-> System.out.println(n));
		
16. Meeting points of elements in given arrays

        int[] arr1 = {1, 2, 13, 4, 5};
        int[] arr2 = {6, 13, 9};

        List<Integer> list = Arrays.stream(arr1).filter(x -> Arrays.stream(arr2).anyMatch(y -> y == x))
                .boxed()
                .collect(Collectors.toList());

        System.out.println(list);


        for (int i : arr1){
            for (int j : arr2){
                if(i == j){
                    System.out.println(i);
                }
            }
        }
	
17.  String str = "java is my tech";
     System.out.println(Arrays.stream(str.split(" ")).map(l-> new StringBuffer(l).reverse().toString()).collect(Collectors.joining(" ")));
	 
	 (or)
	 
	    String str = "java is my tech";
        String[] list = str.split(" ");
        String revString = "";
        for (String li : list){
            revString = revString + " "+ new StringBuffer(li).reverse().toString();
        }
        System.out.println(revString);
		
		
18. count the each word length 
	
		String str = "java is my tech";
        System.out.println(Arrays.stream(str.split(" ")).collect(Collectors.toMap(l-> l, l-> l.length())));
		
19. get the max length word in given string

	    String str = "java1 is my tech1";
        System.out.println(Arrays.stream(str.split(" ")).max(Comparator.comparing(String::length)).get());

20. Finding average salary using Streams
			double averageSalary =
				employees.stream()
						 .mapToDouble(Employee::getSalary)
						 .average()
						 .orElse(0.0);

				System.out.println(averageSalary);
				
21. Find out all the numbers starting with 1 using stream function
	
		 List<Integer> list = List.of(11, 18, 20, 24, 85, 66, 13);
		 System.out.println(list.stream().filter(l-> String.valueOf(l).startsWith("1")).collect(Collectors.toList()));

22. compare two array order not important


		int[] arr1 = {3, 2, 5, 7};
		int[] arr2 = {2, 3, 5, 7};

		Arrays.sort(arr1);
		Arrays.sort(arr2);

		boolean isSame = Arrays.equals(arr1, arr2);

		System.out.println(isSame);
		
23. Find the special char in given string

		String str = "Java@123#Dev!";

		for (char ch : str.toCharArray()) {

			if (!Character.isLetterOrDigit(ch)) {
				System.out.print(ch + " ");
			}
		} 
		
24. Convert 1st half to Lowercase and 2nd half to uppercase
		 
		String str = "JaVaProGraM";
        int mid = str.length()/2;
        String firstHalf = str.substring(0, mid).toLowerCase();
        String secondHalf = str.substring(mid, str.length()).toUpperCase();
        System.out.println(firstHalf + secondHalf);


25. Get the highest paid Employee on each dept 

		List<Empolyee> emp = List.of(
            new Empolyee(20, "abc", 5000,"IT"),
            new Empolyee(21, "xyz", 6000,"HR"),
            new Empolyee(22, "pqr", 3000,"HR"),
            new Empolyee(23, "nmc", 4000,"IT")
		);


        Map<String, Optional<Empolyee>> collect = emp.stream().collect(Collectors.groupingBy(Empolyee::getDept,
                Collectors.maxBy(Comparator.comparingDouble(Empolyee::getSalary))));

        collect.forEach( (a, b) -> System.out.println(a + " => "  + b.get().getName() ));
		
26. Find the words starting with vowels
		String str = "Urrah! java my code is working!";
		
        System.out.println(Arrays.stream(str.split(" "))
                .filter(w -> "AEIOUaeiou".indexOf(w.charAt(0)) != -1)
                .collect(Collectors.toList()));
				
27.  get the employee details for each dept
		 List<Empolyee> emp = List.of(
            new Empolyee(20, "abc", 5000,"IT"),
            new Empolyee(21, "xyz", 6000,"HR"),
            new Empolyee(22, "pqr", 3000,"HR"),
            new Empolyee(23, "nmc", 4000,"IT")
		);

        Map<String, List<Empolyee>> deptMap = emp.stream().collect(Collectors.groupingBy(Empolyee::getDept));

        deptMap.forEach((dept, empList) -> {

            System.out.println("Department: " + dept);

            empList.forEach(emp1 ->
                    System.out.println("Name: " + emp1.getName()
                            + ", Salary: " + emp1.getSalary())
            );

            System.out.println();
        });
		
28. get the employee who earn above average salary

			double average = emp.stream().mapToDouble(Empolyee::getSalary).average().orElse(0);
			emp.stream().filter(l-> l.getSalary() > average).forEach(l-> System.out.println(l.getName()));


29. If you add a null value to an empty Set, what will be the size?

        Set<Integer> set = new HashSet<>();
        set.add(null);
        System.out.println(set.size());	//1  same for List aswell


		
== Introduction ====
	
Hi, I‚Äôm Roy. I have around 5.5 years of experience as a Full Stack Developer working mainly with Angular and Spring Boot.
Currently, I‚Äôm working on an insurance domain product where I build scalable frontend modules using Angular 
and Nx UI components and develop backend microservices using Spring Boot, Hibernate, and REST APIs.

My key responsibilities include designing reusable UI components, handling complex reactive forms, responsiveness apps using bootstrap
integrating APIs, implementing business logic, optimizing performance, and ensuring secure communication between services.

I also have experience with Docker for containerizing applications and basic AWS services like EC2 and S3 for deployment.

(GAF's score => where we call API to get the rsting of vehicle information )


	
Tell me about a challenging issue you faced in a project
How do you handle production incidents?
How do you manage tight deadlines?
How do you handle disagreements with teammates?
Have you worked with clients directly?
	












